diff --git a/include/nvml.h b/include/nvml.h
new file mode 100644
index 0000000..ed7c3e0
--- /dev/null
+++ b/include/nvml.h
@@ -0,0 +1,1014 @@
+#ifndef __nvml_nvml_h__
+#define __nvml_nvml_h__ 
+#ifdef __cplusplus
+extern "C" {
+#endif
+#if defined _WINDOWS
+    #if !defined NVML_STATIC_IMPORT
+        #if defined NVML_LIB_EXPORT
+            #define DECLDIR __declspec(dllexport)
+        #else
+            #define DECLDIR __declspec(dllimport)
+        #endif
+    #else
+        #define DECLDIR
+    #endif
+#else
+    #define DECLDIR
+#endif
+#define NVML_API_VERSION 10
+#define NVML_API_VERSION_STR "10"
+#define nvmlInit nvmlInit_v2
+#define nvmlDeviceGetPciInfo nvmlDeviceGetPciInfo_v3
+#define nvmlDeviceGetCount nvmlDeviceGetCount_v2
+#define nvmlDeviceGetHandleByIndex nvmlDeviceGetHandleByIndex_v2
+#define nvmlDeviceGetHandleByPciBusId nvmlDeviceGetHandleByPciBusId_v2
+#define nvmlDeviceGetNvLinkRemotePciInfo nvmlDeviceGetNvLinkRemotePciInfo_v2
+#define nvmlDeviceRemoveGpu nvmlDeviceRemoveGpu_v2
+#define nvmlDeviceGetGridLicensableFeatures nvmlDeviceGetGridLicensableFeatures_v3
+#define NVML_VALUE_NOT_AVAILABLE (-1)
+typedef struct nvmlDevice_st* nvmlDevice_t;
+#define NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE 32
+#define NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE 16
+typedef struct nvmlPciInfo_st
+{
+    char busIdLegacy[NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE];
+    unsigned int domain;
+    unsigned int bus;
+    unsigned int device;
+    unsigned int pciDeviceId;
+    unsigned int pciSubSystemId;
+    char busId[NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE];
+} nvmlPciInfo_t;
+#define NVML_DEVICE_PCI_BUS_ID_LEGACY_FMT "%04X:%02X:%02X.0"
+#define NVML_DEVICE_PCI_BUS_ID_FMT "%08X:%02X:%02X.0"
+#define NVML_DEVICE_PCI_BUS_ID_FMT_ARGS(pciInfo) (pciInfo)->domain, \
+                                                    (pciInfo)->bus, \
+                                                    (pciInfo)->device
+typedef struct nvmlEccErrorCounts_st
+{
+    unsigned long long l1Cache;
+    unsigned long long l2Cache;
+    unsigned long long deviceMemory;
+    unsigned long long registerFile;
+} nvmlEccErrorCounts_t;
+typedef struct nvmlUtilization_st
+{
+    unsigned int gpu;
+    unsigned int memory;
+} nvmlUtilization_t;
+typedef struct nvmlMemory_st
+{
+    unsigned long long total;
+    unsigned long long free;
+    unsigned long long used;
+} nvmlMemory_t;
+typedef struct nvmlBAR1Memory_st
+{
+    unsigned long long bar1Total;
+    unsigned long long bar1Free;
+    unsigned long long bar1Used;
+}nvmlBAR1Memory_t;
+typedef struct nvmlProcessInfo_st
+{
+    unsigned int pid;
+    unsigned long long usedGpuMemory;
+} nvmlProcessInfo_t;
+typedef enum nvmlBridgeChipType_enum
+{
+    NVML_BRIDGE_CHIP_PLX = 0,
+    NVML_BRIDGE_CHIP_BRO4 = 1
+}nvmlBridgeChipType_t;
+#define NVML_NVLINK_MAX_LINKS 6
+typedef enum nvmlNvLinkUtilizationCountUnits_enum
+{
+    NVML_NVLINK_COUNTER_UNIT_CYCLES = 0,
+    NVML_NVLINK_COUNTER_UNIT_PACKETS = 1,
+    NVML_NVLINK_COUNTER_UNIT_BYTES = 2,
+    NVML_NVLINK_COUNTER_UNIT_RESERVED = 3,
+    NVML_NVLINK_COUNTER_UNIT_COUNT
+} nvmlNvLinkUtilizationCountUnits_t;
+typedef enum nvmlNvLinkUtilizationCountPktTypes_enum
+{
+    NVML_NVLINK_COUNTER_PKTFILTER_NOP = 0x1,
+    NVML_NVLINK_COUNTER_PKTFILTER_READ = 0x2,
+    NVML_NVLINK_COUNTER_PKTFILTER_WRITE = 0x4,
+    NVML_NVLINK_COUNTER_PKTFILTER_RATOM = 0x8,
+    NVML_NVLINK_COUNTER_PKTFILTER_NRATOM = 0x10,
+    NVML_NVLINK_COUNTER_PKTFILTER_FLUSH = 0x20,
+    NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA = 0x40,
+    NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA = 0x80,
+    NVML_NVLINK_COUNTER_PKTFILTER_ALL = 0xFF
+} nvmlNvLinkUtilizationCountPktTypes_t;
+typedef struct nvmlNvLinkUtilizationControl_st
+{
+    nvmlNvLinkUtilizationCountUnits_t units;
+    nvmlNvLinkUtilizationCountPktTypes_t pktfilter;
+} nvmlNvLinkUtilizationControl_t;
+typedef enum nvmlNvLinkCapability_enum
+{
+    NVML_NVLINK_CAP_P2P_SUPPORTED = 0,
+    NVML_NVLINK_CAP_SYSMEM_ACCESS = 1,
+    NVML_NVLINK_CAP_P2P_ATOMICS = 2,
+    NVML_NVLINK_CAP_SYSMEM_ATOMICS= 3,
+    NVML_NVLINK_CAP_SLI_BRIDGE = 4,
+    NVML_NVLINK_CAP_VALID = 5,
+    NVML_NVLINK_CAP_COUNT
+} nvmlNvLinkCapability_t;
+typedef enum nvmlNvLinkErrorCounter_enum
+{
+    NVML_NVLINK_ERROR_DL_REPLAY = 0,
+    NVML_NVLINK_ERROR_DL_RECOVERY = 1,
+    NVML_NVLINK_ERROR_DL_CRC_FLIT = 2,
+    NVML_NVLINK_ERROR_DL_CRC_DATA = 3,
+    NVML_NVLINK_ERROR_COUNT
+} nvmlNvLinkErrorCounter_t;
+typedef enum nvmlGpuLevel_enum
+{
+    NVML_TOPOLOGY_INTERNAL = 0,
+    NVML_TOPOLOGY_SINGLE = 10,
+    NVML_TOPOLOGY_MULTIPLE = 20,
+    NVML_TOPOLOGY_HOSTBRIDGE = 30,
+    NVML_TOPOLOGY_NODE = 40,
+    NVML_TOPOLOGY_SYSTEM = 50,
+} nvmlGpuTopologyLevel_t;
+#define NVML_TOPOLOGY_CPU NVML_TOPOLOGY_NODE
+typedef enum nvmlGpuP2PStatus_enum
+{
+    NVML_P2P_STATUS_OK = 0,
+    NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED,
+    NVML_P2P_STATUS_GPU_NOT_SUPPORTED,
+    NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED,
+    NVML_P2P_STATUS_DISABLED_BY_REGKEY,
+    NVML_P2P_STATUS_NOT_SUPPORTED,
+    NVML_P2P_STATUS_UNKNOWN
+} nvmlGpuP2PStatus_t;
+typedef enum nvmlGpuP2PCapsIndex_enum
+{
+    NVML_P2P_CAPS_INDEX_READ = 0,
+    NVML_P2P_CAPS_INDEX_WRITE,
+    NVML_P2P_CAPS_INDEX_NVLINK,
+    NVML_P2P_CAPS_INDEX_ATOMICS,
+    NVML_P2P_CAPS_INDEX_PROP,
+    NVML_P2P_CAPS_INDEX_UNKNOWN
+}nvmlGpuP2PCapsIndex_t;
+#define NVML_MAX_PHYSICAL_BRIDGE (128)
+typedef struct nvmlBridgeChipInfo_st
+{
+    nvmlBridgeChipType_t type;
+    unsigned int fwVersion;
+}nvmlBridgeChipInfo_t;
+typedef struct nvmlBridgeChipHierarchy_st
+{
+    unsigned char bridgeCount;
+    nvmlBridgeChipInfo_t bridgeChipInfo[NVML_MAX_PHYSICAL_BRIDGE];
+}nvmlBridgeChipHierarchy_t;
+typedef enum nvmlSamplingType_enum
+{
+    NVML_TOTAL_POWER_SAMPLES = 0,
+    NVML_GPU_UTILIZATION_SAMPLES = 1,
+    NVML_MEMORY_UTILIZATION_SAMPLES = 2,
+    NVML_ENC_UTILIZATION_SAMPLES = 3,
+    NVML_DEC_UTILIZATION_SAMPLES = 4,
+    NVML_PROCESSOR_CLK_SAMPLES = 5,
+    NVML_MEMORY_CLK_SAMPLES = 6,
+    NVML_SAMPLINGTYPE_COUNT
+}nvmlSamplingType_t;
+typedef enum nvmlPcieUtilCounter_enum
+{
+    NVML_PCIE_UTIL_TX_BYTES = 0,
+    NVML_PCIE_UTIL_RX_BYTES = 1,
+    NVML_PCIE_UTIL_COUNT
+} nvmlPcieUtilCounter_t;
+typedef enum nvmlValueType_enum
+{
+    NVML_VALUE_TYPE_DOUBLE = 0,
+    NVML_VALUE_TYPE_UNSIGNED_INT = 1,
+    NVML_VALUE_TYPE_UNSIGNED_LONG = 2,
+    NVML_VALUE_TYPE_UNSIGNED_LONG_LONG = 3,
+    NVML_VALUE_TYPE_SIGNED_LONG_LONG = 4,
+    NVML_VALUE_TYPE_COUNT
+}nvmlValueType_t;
+typedef union nvmlValue_st
+{
+    double dVal;
+    unsigned int uiVal;
+    unsigned long ulVal;
+    unsigned long long ullVal;
+    signed long long sllVal;
+}nvmlValue_t;
+typedef struct nvmlSample_st
+{
+    unsigned long long timeStamp;
+    nvmlValue_t sampleValue;
+}nvmlSample_t;
+typedef enum nvmlPerfPolicyType_enum
+{
+    NVML_PERF_POLICY_POWER = 0,
+    NVML_PERF_POLICY_THERMAL = 1,
+    NVML_PERF_POLICY_SYNC_BOOST = 2,
+    NVML_PERF_POLICY_BOARD_LIMIT = 3,
+    NVML_PERF_POLICY_LOW_UTILIZATION = 4,
+    NVML_PERF_POLICY_RELIABILITY = 5,
+    NVML_PERF_POLICY_TOTAL_APP_CLOCKS = 10,
+    NVML_PERF_POLICY_TOTAL_BASE_CLOCKS = 11,
+    NVML_PERF_POLICY_COUNT
+}nvmlPerfPolicyType_t;
+typedef struct nvmlViolationTime_st
+{
+    unsigned long long referenceTime;
+    unsigned long long violationTime;
+}nvmlViolationTime_t;
+typedef enum nvmlEnableState_enum
+{
+    NVML_FEATURE_DISABLED = 0,
+    NVML_FEATURE_ENABLED = 1
+} nvmlEnableState_t;
+#define nvmlFlagDefault 0x00
+#define nvmlFlagForce 0x01
+typedef enum nvmlBrandType_enum
+{
+    NVML_BRAND_UNKNOWN = 0,
+    NVML_BRAND_QUADRO = 1,
+    NVML_BRAND_TESLA = 2,
+    NVML_BRAND_NVS = 3,
+    NVML_BRAND_GRID = 4,
+    NVML_BRAND_GEFORCE = 5,
+    NVML_BRAND_TITAN = 6,
+    NVML_BRAND_COUNT
+} nvmlBrandType_t;
+typedef enum nvmlTemperatureThresholds_enum
+{
+    NVML_TEMPERATURE_THRESHOLD_SHUTDOWN = 0,
+    NVML_TEMPERATURE_THRESHOLD_SLOWDOWN = 1,
+    NVML_TEMPERATURE_THRESHOLD_MEM_MAX = 2,
+    NVML_TEMPERATURE_THRESHOLD_GPU_MAX = 3,
+    NVML_TEMPERATURE_THRESHOLD_COUNT
+} nvmlTemperatureThresholds_t;
+typedef enum nvmlTemperatureSensors_enum
+{
+    NVML_TEMPERATURE_GPU = 0,
+    NVML_TEMPERATURE_COUNT
+} nvmlTemperatureSensors_t;
+typedef enum nvmlComputeMode_enum
+{
+    NVML_COMPUTEMODE_DEFAULT = 0,
+    NVML_COMPUTEMODE_EXCLUSIVE_THREAD = 1,
+    NVML_COMPUTEMODE_PROHIBITED = 2,
+    NVML_COMPUTEMODE_EXCLUSIVE_PROCESS = 3,
+    NVML_COMPUTEMODE_COUNT
+} nvmlComputeMode_t;
+#define nvmlEccBitType_t nvmlMemoryErrorType_t
+#define NVML_SINGLE_BIT_ECC NVML_MEMORY_ERROR_TYPE_CORRECTED
+#define NVML_DOUBLE_BIT_ECC NVML_MEMORY_ERROR_TYPE_UNCORRECTED
+typedef enum nvmlMemoryErrorType_enum
+{
+    NVML_MEMORY_ERROR_TYPE_CORRECTED = 0,
+    NVML_MEMORY_ERROR_TYPE_UNCORRECTED = 1,
+    NVML_MEMORY_ERROR_TYPE_COUNT
+} nvmlMemoryErrorType_t;
+typedef enum nvmlEccCounterType_enum
+{
+    NVML_VOLATILE_ECC = 0,
+    NVML_AGGREGATE_ECC = 1,
+    NVML_ECC_COUNTER_TYPE_COUNT
+} nvmlEccCounterType_t;
+typedef enum nvmlClockType_enum
+{
+    NVML_CLOCK_GRAPHICS = 0,
+    NVML_CLOCK_SM = 1,
+    NVML_CLOCK_MEM = 2,
+    NVML_CLOCK_VIDEO = 3,
+    NVML_CLOCK_COUNT
+} nvmlClockType_t;
+typedef enum nvmlClockId_enum
+{
+    NVML_CLOCK_ID_CURRENT = 0,
+    NVML_CLOCK_ID_APP_CLOCK_TARGET = 1,
+    NVML_CLOCK_ID_APP_CLOCK_DEFAULT = 2,
+    NVML_CLOCK_ID_CUSTOMER_BOOST_MAX = 3,
+    NVML_CLOCK_ID_COUNT
+} nvmlClockId_t;
+typedef enum nvmlDriverModel_enum
+{
+    NVML_DRIVER_WDDM = 0,
+    NVML_DRIVER_WDM = 1
+} nvmlDriverModel_t;
+typedef enum nvmlPStates_enum
+{
+    NVML_PSTATE_0 = 0,
+    NVML_PSTATE_1 = 1,
+    NVML_PSTATE_2 = 2,
+    NVML_PSTATE_3 = 3,
+    NVML_PSTATE_4 = 4,
+    NVML_PSTATE_5 = 5,
+    NVML_PSTATE_6 = 6,
+    NVML_PSTATE_7 = 7,
+    NVML_PSTATE_8 = 8,
+    NVML_PSTATE_9 = 9,
+    NVML_PSTATE_10 = 10,
+    NVML_PSTATE_11 = 11,
+    NVML_PSTATE_12 = 12,
+    NVML_PSTATE_13 = 13,
+    NVML_PSTATE_14 = 14,
+    NVML_PSTATE_15 = 15,
+    NVML_PSTATE_UNKNOWN = 32
+} nvmlPstates_t;
+typedef enum nvmlGom_enum
+{
+    NVML_GOM_ALL_ON = 0,
+    NVML_GOM_COMPUTE = 1,
+    NVML_GOM_LOW_DP = 2
+} nvmlGpuOperationMode_t;
+typedef enum nvmlInforomObject_enum
+{
+    NVML_INFOROM_OEM = 0,
+    NVML_INFOROM_ECC = 1,
+    NVML_INFOROM_POWER = 2,
+    NVML_INFOROM_COUNT
+} nvmlInforomObject_t;
+typedef enum nvmlReturn_enum
+{
+    NVML_SUCCESS = 0,
+    NVML_ERROR_UNINITIALIZED = 1,
+    NVML_ERROR_INVALID_ARGUMENT = 2,
+    NVML_ERROR_NOT_SUPPORTED = 3,
+    NVML_ERROR_NO_PERMISSION = 4,
+    NVML_ERROR_ALREADY_INITIALIZED = 5,
+    NVML_ERROR_NOT_FOUND = 6,
+    NVML_ERROR_INSUFFICIENT_SIZE = 7,
+    NVML_ERROR_INSUFFICIENT_POWER = 8,
+    NVML_ERROR_DRIVER_NOT_LOADED = 9,
+    NVML_ERROR_TIMEOUT = 10,
+    NVML_ERROR_IRQ_ISSUE = 11,
+    NVML_ERROR_LIBRARY_NOT_FOUND = 12,
+    NVML_ERROR_FUNCTION_NOT_FOUND = 13,
+    NVML_ERROR_CORRUPTED_INFOROM = 14,
+    NVML_ERROR_GPU_IS_LOST = 15,
+    NVML_ERROR_RESET_REQUIRED = 16,
+    NVML_ERROR_OPERATING_SYSTEM = 17,
+    NVML_ERROR_LIB_RM_VERSION_MISMATCH = 18,
+    NVML_ERROR_IN_USE = 19,
+    NVML_ERROR_MEMORY = 20,
+    NVML_ERROR_NO_DATA = 21,
+    NVML_ERROR_VGPU_ECC_NOT_SUPPORTED = 22,
+    NVML_ERROR_UNKNOWN = 999
+} nvmlReturn_t;
+typedef enum nvmlMemoryLocation_enum
+{
+    NVML_MEMORY_LOCATION_L1_CACHE = 0,
+    NVML_MEMORY_LOCATION_L2_CACHE = 1,
+    NVML_MEMORY_LOCATION_DRAM = 2,
+    NVML_MEMORY_LOCATION_DEVICE_MEMORY = 2,
+    NVML_MEMORY_LOCATION_REGISTER_FILE = 3,
+    NVML_MEMORY_LOCATION_TEXTURE_MEMORY = 4,
+    NVML_MEMORY_LOCATION_TEXTURE_SHM = 5,
+    NVML_MEMORY_LOCATION_CBU = 6,
+    NVML_MEMORY_LOCATION_SRAM = 7,
+    NVML_MEMORY_LOCATION_COUNT
+} nvmlMemoryLocation_t;
+typedef enum nvmlPageRetirementCause_enum
+{
+    NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS = 0,
+    NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR = 1,
+    NVML_PAGE_RETIREMENT_CAUSE_COUNT
+} nvmlPageRetirementCause_t;
+typedef enum nvmlRestrictedAPI_enum
+{
+    NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS = 0,
+    NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS = 1,
+    NVML_RESTRICTED_API_COUNT
+} nvmlRestrictedAPI_t;
+typedef enum nvmlGpuVirtualizationMode {
+    NVML_GPU_VIRTUALIZATION_MODE_NONE = 0,
+    NVML_GPU_VIRTUALIZATION_MODE_PASSTHROUGH = 1,
+    NVML_GPU_VIRTUALIZATION_MODE_VGPU = 2,
+    NVML_GPU_VIRTUALIZATION_MODE_HOST_VGPU = 3,
+    NVML_GPU_VIRTUALIZATION_MODE_HOST_VSGA = 4,
+} nvmlGpuVirtualizationMode_t;
+typedef enum nvmlHostVgpuMode_enum
+{
+    NVML_HOST_VGPU_MODE_NON_SRIOV = 0,
+    NVML_HOST_VGPU_MODE_SRIOV = 1
+} nvmlHostVgpuMode_t;
+typedef enum nvmlVgpuVmIdType {
+    NVML_VGPU_VM_ID_DOMAIN_ID = 0,
+    NVML_VGPU_VM_ID_UUID = 1,
+} nvmlVgpuVmIdType_t;
+typedef enum nvmlVgpuGuestInfoState_enum
+{
+    NVML_VGPU_INSTANCE_GUEST_INFO_STATE_UNINITIALIZED = 0,
+    NVML_VGPU_INSTANCE_GUEST_INFO_STATE_INITIALIZED = 1,
+} nvmlVgpuGuestInfoState_t;
+typedef enum {
+    NVML_GRID_LICENSE_FEATURE_CODE_VGPU = 1,
+    NVML_GRID_LICENSE_FEATURE_CODE_VWORKSTATION = 2
+} nvmlGridLicenseFeatureCode_t;
+#define NVML_GRID_LICENSE_BUFFER_SIZE 128
+#define NVML_VGPU_NAME_BUFFER_SIZE 64
+#define NVML_GRID_LICENSE_FEATURE_MAX_COUNT 3
+#define NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION 0:0
+#define NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_NO 0x0
+#define NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_YES 0x1
+#define NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION 0:0
+#define NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_NO 0x0
+#define NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_YES 0x1
+typedef unsigned int nvmlVgpuTypeId_t;
+typedef unsigned int nvmlVgpuInstance_t;
+typedef struct nvmlVgpuInstanceUtilizationSample_st
+{
+    nvmlVgpuInstance_t vgpuInstance;
+    unsigned long long timeStamp;
+    nvmlValue_t smUtil;
+    nvmlValue_t memUtil;
+    nvmlValue_t encUtil;
+    nvmlValue_t decUtil;
+} nvmlVgpuInstanceUtilizationSample_t;
+typedef struct nvmlVgpuProcessUtilizationSample_st
+{
+    nvmlVgpuInstance_t vgpuInstance;
+    unsigned int pid;
+    char processName[NVML_VGPU_NAME_BUFFER_SIZE];
+    unsigned long long timeStamp;
+    unsigned int smUtil;
+    unsigned int memUtil;
+    unsigned int encUtil;
+    unsigned int decUtil;
+} nvmlVgpuProcessUtilizationSample_t;
+typedef struct nvmlProcessUtilizationSample_st
+{
+    unsigned int pid;
+    unsigned long long timeStamp;
+    unsigned int smUtil;
+    unsigned int memUtil;
+    unsigned int encUtil;
+    unsigned int decUtil;
+} nvmlProcessUtilizationSample_t;
+typedef struct nvmlGridLicensableFeature_st
+{
+    nvmlGridLicenseFeatureCode_t featureCode;
+    unsigned int featureState;
+    char licenseInfo[NVML_GRID_LICENSE_BUFFER_SIZE];
+    char productName[NVML_GRID_LICENSE_BUFFER_SIZE];
+    unsigned int featureEnabled;
+} nvmlGridLicensableFeature_t;
+typedef struct nvmlGridLicensableFeatures_st
+{
+    int isGridLicenseSupported;
+    unsigned int licensableFeaturesCount;
+    nvmlGridLicensableFeature_t gridLicensableFeatures[NVML_GRID_LICENSE_FEATURE_MAX_COUNT];
+} nvmlGridLicensableFeatures_t;
+#define NVML_FI_DEV_ECC_CURRENT 1
+#define NVML_FI_DEV_ECC_PENDING 2
+#define NVML_FI_DEV_ECC_SBE_VOL_TOTAL 3
+#define NVML_FI_DEV_ECC_DBE_VOL_TOTAL 4
+#define NVML_FI_DEV_ECC_SBE_AGG_TOTAL 5
+#define NVML_FI_DEV_ECC_DBE_AGG_TOTAL 6
+#define NVML_FI_DEV_ECC_SBE_VOL_L1 7
+#define NVML_FI_DEV_ECC_DBE_VOL_L1 8
+#define NVML_FI_DEV_ECC_SBE_VOL_L2 9
+#define NVML_FI_DEV_ECC_DBE_VOL_L2 10
+#define NVML_FI_DEV_ECC_SBE_VOL_DEV 11
+#define NVML_FI_DEV_ECC_DBE_VOL_DEV 12
+#define NVML_FI_DEV_ECC_SBE_VOL_REG 13
+#define NVML_FI_DEV_ECC_DBE_VOL_REG 14
+#define NVML_FI_DEV_ECC_SBE_VOL_TEX 15
+#define NVML_FI_DEV_ECC_DBE_VOL_TEX 16
+#define NVML_FI_DEV_ECC_DBE_VOL_CBU 17
+#define NVML_FI_DEV_ECC_SBE_AGG_L1 18
+#define NVML_FI_DEV_ECC_DBE_AGG_L1 19
+#define NVML_FI_DEV_ECC_SBE_AGG_L2 20
+#define NVML_FI_DEV_ECC_DBE_AGG_L2 21
+#define NVML_FI_DEV_ECC_SBE_AGG_DEV 22
+#define NVML_FI_DEV_ECC_DBE_AGG_DEV 23
+#define NVML_FI_DEV_ECC_SBE_AGG_REG 24
+#define NVML_FI_DEV_ECC_DBE_AGG_REG 25
+#define NVML_FI_DEV_ECC_SBE_AGG_TEX 26
+#define NVML_FI_DEV_ECC_DBE_AGG_TEX 27
+#define NVML_FI_DEV_ECC_DBE_AGG_CBU 28
+#define NVML_FI_DEV_RETIRED_SBE 29
+#define NVML_FI_DEV_RETIRED_DBE 30
+#define NVML_FI_DEV_RETIRED_PENDING 31
+#define NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L0 32
+#define NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L1 33
+#define NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L2 34
+#define NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L3 35
+#define NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L4 36
+#define NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L5 37
+#define NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_TOTAL 38
+#define NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L0 39
+#define NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L1 40
+#define NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L2 41
+#define NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L3 42
+#define NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L4 43
+#define NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L5 44
+#define NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_TOTAL 45
+#define NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L0 46
+#define NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L1 47
+#define NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L2 48
+#define NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L3 49
+#define NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L4 50
+#define NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L5 51
+#define NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_TOTAL 52
+#define NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L0 53
+#define NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L1 54
+#define NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L2 55
+#define NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L3 56
+#define NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L4 57
+#define NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L5 58
+#define NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_TOTAL 59
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L0 60
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L1 61
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L2 62
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L3 63
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L4 64
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L5 65
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C0_TOTAL 66
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L0 67
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L1 68
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L2 69
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L3 70
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L4 71
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L5 72
+#define NVML_FI_DEV_NVLINK_BANDWIDTH_C1_TOTAL 73
+#define NVML_FI_DEV_PERF_POLICY_POWER 74
+#define NVML_FI_DEV_PERF_POLICY_THERMAL 75
+#define NVML_FI_DEV_PERF_POLICY_SYNC_BOOST 76
+#define NVML_FI_DEV_PERF_POLICY_BOARD_LIMIT 77
+#define NVML_FI_DEV_PERF_POLICY_LOW_UTILIZATION 78
+#define NVML_FI_DEV_PERF_POLICY_RELIABILITY 79
+#define NVML_FI_DEV_PERF_POLICY_TOTAL_APP_CLOCKS 80
+#define NVML_FI_DEV_PERF_POLICY_TOTAL_BASE_CLOCKS 81
+#define NVML_FI_DEV_MEMORY_TEMP 82
+#define NVML_FI_DEV_TOTAL_ENERGY_CONSUMPTION 83
+#define NVML_FI_DEV_NVLINK_SPEED_MBPS_L0 84
+#define NVML_FI_DEV_NVLINK_SPEED_MBPS_L1 85
+#define NVML_FI_DEV_NVLINK_SPEED_MBPS_L2 86
+#define NVML_FI_DEV_NVLINK_SPEED_MBPS_L3 87
+#define NVML_FI_DEV_NVLINK_SPEED_MBPS_L4 88
+#define NVML_FI_DEV_NVLINK_SPEED_MBPS_L5 89
+#define NVML_FI_DEV_NVLINK_SPEED_MBPS_COMMON 90
+#define NVML_FI_DEV_NVLINK_LINK_COUNT 91
+#define NVML_FI_DEV_RETIRED_PENDING_SBE 92
+#define NVML_FI_DEV_RETIRED_PENDING_DBE 93
+#define NVML_FI_DEV_PCIE_REPLAY_COUNTER 94
+#define NVML_FI_DEV_PCIE_REPLAY_ROLLOVER_COUNTER 95
+#define NVML_FI_MAX 96
+typedef struct nvmlFieldValue_st
+{
+    unsigned int fieldId;
+    unsigned int unused;
+    long long timestamp;
+    long long latencyUsec;
+    nvmlValueType_t valueType;
+    nvmlReturn_t nvmlReturn;
+    nvmlValue_t value;
+} nvmlFieldValue_t;
+typedef struct nvmlUnit_st* nvmlUnit_t;
+typedef struct nvmlHwbcEntry_st
+{
+    unsigned int hwbcId;
+    char firmwareVersion[32];
+} nvmlHwbcEntry_t;
+typedef enum nvmlFanState_enum
+{
+    NVML_FAN_NORMAL = 0,
+    NVML_FAN_FAILED = 1
+} nvmlFanState_t;
+typedef enum nvmlLedColor_enum
+{
+    NVML_LED_COLOR_GREEN = 0,
+    NVML_LED_COLOR_AMBER = 1
+} nvmlLedColor_t;
+typedef struct nvmlLedState_st
+{
+    char cause[256];
+    nvmlLedColor_t color;
+} nvmlLedState_t;
+typedef struct nvmlUnitInfo_st
+{
+    char name[96];
+    char id[96];
+    char serial[96];
+    char firmwareVersion[96];
+} nvmlUnitInfo_t;
+typedef struct nvmlPSUInfo_st
+{
+    char state[256];
+    unsigned int current;
+    unsigned int voltage;
+    unsigned int power;
+} nvmlPSUInfo_t;
+typedef struct nvmlUnitFanInfo_st
+{
+    unsigned int speed;
+    nvmlFanState_t state;
+} nvmlUnitFanInfo_t;
+typedef struct nvmlUnitFanSpeeds_st
+{
+    nvmlUnitFanInfo_t fans[24];
+    unsigned int count;
+} nvmlUnitFanSpeeds_t;
+typedef struct nvmlEventSet_st* nvmlEventSet_t;
+#define nvmlEventTypeSingleBitEccError 0x0000000000000001LL
+#define nvmlEventTypeDoubleBitEccError 0x0000000000000002LL
+#define nvmlEventTypePState 0x0000000000000004LL
+#define nvmlEventTypeXidCriticalError 0x0000000000000008LL
+#define nvmlEventTypeClock 0x0000000000000010LL
+#define nvmlEventTypeNone 0x0000000000000000LL
+#define nvmlEventTypeAll (nvmlEventTypeNone \
+        | nvmlEventTypeSingleBitEccError \
+        | nvmlEventTypeDoubleBitEccError \
+        | nvmlEventTypePState \
+        | nvmlEventTypeClock \
+        | nvmlEventTypeXidCriticalError \
+        )
+typedef struct nvmlEventData_st
+{
+    nvmlDevice_t device;
+    unsigned long long eventType;
+    unsigned long long eventData;
+} nvmlEventData_t;
+#define nvmlClocksThrottleReasonGpuIdle 0x0000000000000001LL
+#define nvmlClocksThrottleReasonApplicationsClocksSetting 0x0000000000000002LL
+#define nvmlClocksThrottleReasonUserDefinedClocks nvmlClocksThrottleReasonApplicationsClocksSetting
+#define nvmlClocksThrottleReasonSwPowerCap 0x0000000000000004LL
+#define nvmlClocksThrottleReasonHwSlowdown 0x0000000000000008LL
+#define nvmlClocksThrottleReasonSyncBoost 0x0000000000000010LL
+#define nvmlClocksThrottleReasonSwThermalSlowdown 0x0000000000000020LL
+#define nvmlClocksThrottleReasonHwThermalSlowdown 0x0000000000000040LL
+#define nvmlClocksThrottleReasonHwPowerBrakeSlowdown 0x0000000000000080LL
+#define nvmlClocksThrottleReasonDisplayClockSetting 0x0000000000000100LL
+#define nvmlClocksThrottleReasonNone 0x0000000000000000LL
+#define nvmlClocksThrottleReasonAll (nvmlClocksThrottleReasonNone \
+      | nvmlClocksThrottleReasonGpuIdle \
+      | nvmlClocksThrottleReasonApplicationsClocksSetting \
+      | nvmlClocksThrottleReasonSwPowerCap \
+      | nvmlClocksThrottleReasonHwSlowdown \
+      | nvmlClocksThrottleReasonSyncBoost \
+      | nvmlClocksThrottleReasonSwThermalSlowdown \
+      | nvmlClocksThrottleReasonHwThermalSlowdown \
+      | nvmlClocksThrottleReasonHwPowerBrakeSlowdown \
+      | nvmlClocksThrottleReasonDisplayClockSetting \
+)
+typedef struct nvmlAccountingStats_st {
+    unsigned int gpuUtilization;
+    unsigned int memoryUtilization;
+    unsigned long long maxMemoryUsage;
+    unsigned long long time;
+    unsigned long long startTime;
+    unsigned int isRunning;
+    unsigned int reserved[5];
+} nvmlAccountingStats_t;
+typedef enum nvmlEncoderQueryType_enum
+{
+    NVML_ENCODER_QUERY_H264 = 0,
+    NVML_ENCODER_QUERY_HEVC = 1,
+}nvmlEncoderType_t;
+typedef struct nvmlEncoderSessionInfo_st
+{
+    unsigned int sessionId;
+    unsigned int pid;
+    nvmlVgpuInstance_t vgpuInstance;
+    nvmlEncoderType_t codecType;
+    unsigned int hResolution;
+    unsigned int vResolution;
+    unsigned int averageFps;
+    unsigned int averageLatency;
+}nvmlEncoderSessionInfo_t;
+typedef enum nvmlFBCSessionType_enum
+{
+    NVML_FBC_SESSION_TYPE_UNKNOWN = 0,
+    NVML_FBC_SESSION_TYPE_TOSYS,
+    NVML_FBC_SESSION_TYPE_CUDA,
+    NVML_FBC_SESSION_TYPE_VID,
+    NVML_FBC_SESSION_TYPE_HWENC,
+} nvmlFBCSessionType_t;
+typedef struct nvmlFBCStats_st
+{
+    unsigned int sessionsCount;
+    unsigned int averageFPS;
+    unsigned int averageLatency;
+} nvmlFBCStats_t;
+#define NVML_NVFBC_SESSION_FLAG_DIFFMAP_ENABLED 0x00000001
+#define NVML_NVFBC_SESSION_FLAG_CLASSIFICATIONMAP_ENABLED 0x00000002
+#define NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_NO_WAIT 0x00000004
+#define NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_INFINITE 0x00000008
+#define NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_TIMEOUT 0x00000010
+typedef struct nvmlFBCSessionInfo_st
+{
+    unsigned int sessionId;
+    unsigned int pid;
+    nvmlVgpuInstance_t vgpuInstance;
+    unsigned int displayOrdinal;
+    nvmlFBCSessionType_t sessionType;
+    unsigned int sessionFlags;
+    unsigned int hMaxResolution;
+    unsigned int vMaxResolution;
+    unsigned int hResolution;
+    unsigned int vResolution;
+    unsigned int averageFPS;
+    unsigned int averageLatency;
+} nvmlFBCSessionInfo_t;
+typedef enum nvmlDetachGpuState_enum
+{
+    NVML_DETACH_GPU_KEEP = 0,
+    NVML_DETACH_GPU_REMOVE,
+} nvmlDetachGpuState_t;
+typedef enum nvmlPcieLinkState_enum
+{
+    NVML_PCIE_LINK_KEEP = 0,
+    NVML_PCIE_LINK_SHUT_DOWN,
+} nvmlPcieLinkState_t;
+#define NVML_INIT_FLAG_NO_GPUS 1
+#define NVML_INIT_FLAG_NO_ATTACH 2
+nvmlReturn_t DECLDIR nvmlInit(void);
+nvmlReturn_t DECLDIR nvmlInitWithFlags(unsigned int flags);
+nvmlReturn_t DECLDIR nvmlShutdown(void);
+const DECLDIR char* nvmlErrorString(nvmlReturn_t result);
+#define NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE 16
+#define NVML_DEVICE_UUID_BUFFER_SIZE 80
+#define NVML_DEVICE_PART_NUMBER_BUFFER_SIZE 80
+#define NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE 80
+#define NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE 80
+#define NVML_DEVICE_NAME_BUFFER_SIZE 64
+#define NVML_DEVICE_SERIAL_BUFFER_SIZE 30
+#define NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE 32
+nvmlReturn_t DECLDIR nvmlSystemGetDriverVersion(char *version, unsigned int length);
+nvmlReturn_t DECLDIR nvmlSystemGetNVMLVersion(char *version, unsigned int length);
+nvmlReturn_t DECLDIR nvmlSystemGetCudaDriverVersion(int *cudaDriverVersion);
+nvmlReturn_t DECLDIR nvmlSystemGetCudaDriverVersion_v2(int *cudaDriverVersion);
+#define NVML_CUDA_DRIVER_VERSION_MAJOR(v) ((v)/1000)
+#define NVML_CUDA_DRIVER_VERSION_MINOR(v) (((v)%1000)/10)
+nvmlReturn_t DECLDIR nvmlSystemGetProcessName(unsigned int pid, char *name, unsigned int length);
+nvmlReturn_t DECLDIR nvmlUnitGetCount(unsigned int *unitCount);
+nvmlReturn_t DECLDIR nvmlUnitGetHandleByIndex(unsigned int index, nvmlUnit_t *unit);
+nvmlReturn_t DECLDIR nvmlUnitGetUnitInfo(nvmlUnit_t unit, nvmlUnitInfo_t *info);
+nvmlReturn_t DECLDIR nvmlUnitGetLedState(nvmlUnit_t unit, nvmlLedState_t *state);
+nvmlReturn_t DECLDIR nvmlUnitGetPsuInfo(nvmlUnit_t unit, nvmlPSUInfo_t *psu);
+nvmlReturn_t DECLDIR nvmlUnitGetTemperature(nvmlUnit_t unit, unsigned int type, unsigned int *temp);
+nvmlReturn_t DECLDIR nvmlUnitGetFanSpeedInfo(nvmlUnit_t unit, nvmlUnitFanSpeeds_t *fanSpeeds);
+nvmlReturn_t DECLDIR nvmlUnitGetDevices(nvmlUnit_t unit, unsigned int *deviceCount, nvmlDevice_t *devices);
+nvmlReturn_t DECLDIR nvmlSystemGetHicVersion(unsigned int *hwbcCount, nvmlHwbcEntry_t *hwbcEntries);
+nvmlReturn_t DECLDIR nvmlDeviceGetCount(unsigned int *deviceCount);
+nvmlReturn_t DECLDIR nvmlDeviceGetHandleByIndex(unsigned int index, nvmlDevice_t *device);
+nvmlReturn_t DECLDIR nvmlDeviceGetHandleBySerial(const char *serial, nvmlDevice_t *device);
+nvmlReturn_t DECLDIR nvmlDeviceGetHandleByUUID(const char *uuid, nvmlDevice_t *device);
+nvmlReturn_t DECLDIR nvmlDeviceGetHandleByPciBusId(const char *pciBusId, nvmlDevice_t *device);
+nvmlReturn_t DECLDIR nvmlDeviceGetName(nvmlDevice_t device, char *name, unsigned int length);
+nvmlReturn_t DECLDIR nvmlDeviceGetBrand(nvmlDevice_t device, nvmlBrandType_t *type);
+nvmlReturn_t DECLDIR nvmlDeviceGetIndex(nvmlDevice_t device, unsigned int *index);
+nvmlReturn_t DECLDIR nvmlDeviceGetSerial(nvmlDevice_t device, char *serial, unsigned int length);
+nvmlReturn_t DECLDIR nvmlDeviceGetCpuAffinity(nvmlDevice_t device, unsigned int cpuSetSize, unsigned long *cpuSet);
+nvmlReturn_t DECLDIR nvmlDeviceSetCpuAffinity(nvmlDevice_t device);
+nvmlReturn_t DECLDIR nvmlDeviceClearCpuAffinity(nvmlDevice_t device);
+nvmlReturn_t DECLDIR nvmlDeviceGetTopologyCommonAncestor(nvmlDevice_t device1, nvmlDevice_t device2, nvmlGpuTopologyLevel_t *pathInfo);
+nvmlReturn_t DECLDIR nvmlDeviceGetTopologyNearestGpus(nvmlDevice_t device, nvmlGpuTopologyLevel_t level, unsigned int *count, nvmlDevice_t *deviceArray);
+nvmlReturn_t DECLDIR nvmlSystemGetTopologyGpuSet(unsigned int cpuNumber, unsigned int *count, nvmlDevice_t *deviceArray);
+nvmlReturn_t DECLDIR nvmlDeviceGetP2PStatus(nvmlDevice_t device1, nvmlDevice_t device2, nvmlGpuP2PCapsIndex_t p2pIndex,nvmlGpuP2PStatus_t *p2pStatus);
+nvmlReturn_t DECLDIR nvmlDeviceGetUUID(nvmlDevice_t device, char *uuid, unsigned int length);
+nvmlReturn_t DECLDIR nvmlDeviceGetMinorNumber(nvmlDevice_t device, unsigned int *minorNumber);
+nvmlReturn_t DECLDIR nvmlDeviceGetBoardPartNumber(nvmlDevice_t device, char* partNumber, unsigned int length);
+nvmlReturn_t DECLDIR nvmlDeviceGetInforomVersion(nvmlDevice_t device, nvmlInforomObject_t object, char *version, unsigned int length);
+nvmlReturn_t DECLDIR nvmlDeviceGetInforomImageVersion(nvmlDevice_t device, char *version, unsigned int length);
+nvmlReturn_t DECLDIR nvmlDeviceGetInforomConfigurationChecksum(nvmlDevice_t device, unsigned int *checksum);
+nvmlReturn_t DECLDIR nvmlDeviceValidateInforom(nvmlDevice_t device);
+nvmlReturn_t DECLDIR nvmlDeviceGetDisplayMode(nvmlDevice_t device, nvmlEnableState_t *display);
+nvmlReturn_t DECLDIR nvmlDeviceGetDisplayActive(nvmlDevice_t device, nvmlEnableState_t *isActive);
+nvmlReturn_t DECLDIR nvmlDeviceGetPersistenceMode(nvmlDevice_t device, nvmlEnableState_t *mode);
+nvmlReturn_t DECLDIR nvmlDeviceGetPciInfo(nvmlDevice_t device, nvmlPciInfo_t *pci);
+nvmlReturn_t DECLDIR nvmlDeviceGetMaxPcieLinkGeneration(nvmlDevice_t device, unsigned int *maxLinkGen);
+nvmlReturn_t DECLDIR nvmlDeviceGetMaxPcieLinkWidth(nvmlDevice_t device, unsigned int *maxLinkWidth);
+nvmlReturn_t DECLDIR nvmlDeviceGetCurrPcieLinkGeneration(nvmlDevice_t device, unsigned int *currLinkGen);
+nvmlReturn_t DECLDIR nvmlDeviceGetCurrPcieLinkWidth(nvmlDevice_t device, unsigned int *currLinkWidth);
+nvmlReturn_t DECLDIR nvmlDeviceGetPcieThroughput(nvmlDevice_t device, nvmlPcieUtilCounter_t counter, unsigned int *value);
+nvmlReturn_t DECLDIR nvmlDeviceGetPcieReplayCounter(nvmlDevice_t device, unsigned int *value);
+nvmlReturn_t DECLDIR nvmlDeviceGetClockInfo(nvmlDevice_t device, nvmlClockType_t type, unsigned int *clock);
+nvmlReturn_t DECLDIR nvmlDeviceGetMaxClockInfo(nvmlDevice_t device, nvmlClockType_t type, unsigned int *clock);
+nvmlReturn_t DECLDIR nvmlDeviceGetApplicationsClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz);
+nvmlReturn_t DECLDIR nvmlDeviceGetDefaultApplicationsClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz);
+nvmlReturn_t DECLDIR nvmlDeviceResetApplicationsClocks(nvmlDevice_t device);
+nvmlReturn_t DECLDIR nvmlDeviceGetClock(nvmlDevice_t device, nvmlClockType_t clockType, nvmlClockId_t clockId, unsigned int *clockMHz);
+nvmlReturn_t DECLDIR nvmlDeviceGetMaxCustomerBoostClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz);
+nvmlReturn_t DECLDIR nvmlDeviceGetSupportedMemoryClocks(nvmlDevice_t device, unsigned int *count, unsigned int *clocksMHz);
+nvmlReturn_t DECLDIR nvmlDeviceGetSupportedGraphicsClocks(nvmlDevice_t device, unsigned int memoryClockMHz, unsigned int *count, unsigned int *clocksMHz);
+nvmlReturn_t DECLDIR nvmlDeviceGetAutoBoostedClocksEnabled(nvmlDevice_t device, nvmlEnableState_t *isEnabled, nvmlEnableState_t *defaultIsEnabled);
+nvmlReturn_t DECLDIR nvmlDeviceSetAutoBoostedClocksEnabled(nvmlDevice_t device, nvmlEnableState_t enabled);
+nvmlReturn_t DECLDIR nvmlDeviceSetDefaultAutoBoostedClocksEnabled(nvmlDevice_t device, nvmlEnableState_t enabled, unsigned int flags);
+nvmlReturn_t DECLDIR nvmlDeviceGetFanSpeed(nvmlDevice_t device, unsigned int *speed);
+nvmlReturn_t DECLDIR nvmlDeviceGetFanSpeed_v2(nvmlDevice_t device, unsigned int fan, unsigned int * speed);
+nvmlReturn_t DECLDIR nvmlDeviceGetTemperature(nvmlDevice_t device, nvmlTemperatureSensors_t sensorType, unsigned int *temp);
+nvmlReturn_t DECLDIR nvmlDeviceGetTemperatureThreshold(nvmlDevice_t device, nvmlTemperatureThresholds_t thresholdType, unsigned int *temp);
+nvmlReturn_t DECLDIR nvmlDeviceGetPerformanceState(nvmlDevice_t device, nvmlPstates_t *pState);
+nvmlReturn_t DECLDIR nvmlDeviceGetCurrentClocksThrottleReasons(nvmlDevice_t device, unsigned long long *clocksThrottleReasons);
+nvmlReturn_t DECLDIR nvmlDeviceGetSupportedClocksThrottleReasons(nvmlDevice_t device, unsigned long long *supportedClocksThrottleReasons);
+nvmlReturn_t DECLDIR nvmlDeviceGetPowerState(nvmlDevice_t device, nvmlPstates_t *pState);
+nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementMode(nvmlDevice_t device, nvmlEnableState_t *mode);
+nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimit(nvmlDevice_t device, unsigned int *limit);
+nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimitConstraints(nvmlDevice_t device, unsigned int *minLimit, unsigned int *maxLimit);
+nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementDefaultLimit(nvmlDevice_t device, unsigned int *defaultLimit);
+nvmlReturn_t DECLDIR nvmlDeviceGetPowerUsage(nvmlDevice_t device, unsigned int *power);
+nvmlReturn_t DECLDIR nvmlDeviceGetTotalEnergyConsumption(nvmlDevice_t device, unsigned long long *energy);
+nvmlReturn_t DECLDIR nvmlDeviceGetEnforcedPowerLimit(nvmlDevice_t device, unsigned int *limit);
+nvmlReturn_t DECLDIR nvmlDeviceGetGpuOperationMode(nvmlDevice_t device, nvmlGpuOperationMode_t *current, nvmlGpuOperationMode_t *pending);
+nvmlReturn_t DECLDIR nvmlDeviceGetMemoryInfo(nvmlDevice_t device, nvmlMemory_t *memory);
+nvmlReturn_t DECLDIR nvmlDeviceGetComputeMode(nvmlDevice_t device, nvmlComputeMode_t *mode);
+nvmlReturn_t DECLDIR nvmlDeviceGetCudaComputeCapability(nvmlDevice_t device, int *major, int *minor);
+nvmlReturn_t DECLDIR nvmlDeviceGetEccMode(nvmlDevice_t device, nvmlEnableState_t *current, nvmlEnableState_t *pending);
+nvmlReturn_t DECLDIR nvmlDeviceGetBoardId(nvmlDevice_t device, unsigned int *boardId);
+nvmlReturn_t DECLDIR nvmlDeviceGetMultiGpuBoard(nvmlDevice_t device, unsigned int *multiGpuBool);
+nvmlReturn_t DECLDIR nvmlDeviceGetTotalEccErrors(nvmlDevice_t device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, unsigned long long *eccCounts);
+nvmlReturn_t DECLDIR nvmlDeviceGetDetailedEccErrors(nvmlDevice_t device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, nvmlEccErrorCounts_t *eccCounts);
+nvmlReturn_t DECLDIR nvmlDeviceGetMemoryErrorCounter(nvmlDevice_t device, nvmlMemoryErrorType_t errorType,
+                                                   nvmlEccCounterType_t counterType,
+                                                   nvmlMemoryLocation_t locationType, unsigned long long *count);
+nvmlReturn_t DECLDIR nvmlDeviceGetUtilizationRates(nvmlDevice_t device, nvmlUtilization_t *utilization);
+nvmlReturn_t DECLDIR nvmlDeviceGetEncoderUtilization(nvmlDevice_t device, unsigned int *utilization, unsigned int *samplingPeriodUs);
+nvmlReturn_t DECLDIR nvmlDeviceGetEncoderCapacity (nvmlDevice_t device, nvmlEncoderType_t encoderQueryType, unsigned int *encoderCapacity);
+nvmlReturn_t DECLDIR nvmlDeviceGetEncoderStats (nvmlDevice_t device, unsigned int *sessionCount,
+                                                unsigned int *averageFps, unsigned int *averageLatency);
+nvmlReturn_t DECLDIR nvmlDeviceGetEncoderSessions(nvmlDevice_t device, unsigned int *sessionCount, nvmlEncoderSessionInfo_t *sessionInfos);
+nvmlReturn_t DECLDIR nvmlDeviceGetDecoderUtilization(nvmlDevice_t device, unsigned int *utilization, unsigned int *samplingPeriodUs);
+nvmlReturn_t DECLDIR nvmlDeviceGetFBCStats(nvmlDevice_t device, nvmlFBCStats_t *fbcStats);
+nvmlReturn_t DECLDIR nvmlDeviceGetFBCSessions(nvmlDevice_t device, unsigned int *sessionCount, nvmlFBCSessionInfo_t *sessionInfo);
+nvmlReturn_t DECLDIR nvmlDeviceGetDriverModel(nvmlDevice_t device, nvmlDriverModel_t *current, nvmlDriverModel_t *pending);
+nvmlReturn_t DECLDIR nvmlDeviceGetVbiosVersion(nvmlDevice_t device, char *version, unsigned int length);
+nvmlReturn_t DECLDIR nvmlDeviceGetBridgeChipInfo(nvmlDevice_t device, nvmlBridgeChipHierarchy_t *bridgeHierarchy);
+nvmlReturn_t DECLDIR nvmlDeviceGetComputeRunningProcesses(nvmlDevice_t device, unsigned int *infoCount, nvmlProcessInfo_t *infos);
+nvmlReturn_t DECLDIR nvmlDeviceGetGraphicsRunningProcesses(nvmlDevice_t device, unsigned int *infoCount, nvmlProcessInfo_t *infos);
+nvmlReturn_t DECLDIR nvmlDeviceOnSameBoard(nvmlDevice_t device1, nvmlDevice_t device2, int *onSameBoard);
+nvmlReturn_t DECLDIR nvmlDeviceGetAPIRestriction(nvmlDevice_t device, nvmlRestrictedAPI_t apiType, nvmlEnableState_t *isRestricted);
+nvmlReturn_t DECLDIR nvmlDeviceGetSamples(nvmlDevice_t device, nvmlSamplingType_t type, unsigned long long lastSeenTimeStamp,
+        nvmlValueType_t *sampleValType, unsigned int *sampleCount, nvmlSample_t *samples);
+nvmlReturn_t DECLDIR nvmlDeviceGetBAR1MemoryInfo(nvmlDevice_t device, nvmlBAR1Memory_t *bar1Memory);
+nvmlReturn_t DECLDIR nvmlDeviceGetViolationStatus(nvmlDevice_t device, nvmlPerfPolicyType_t perfPolicyType, nvmlViolationTime_t *violTime);
+nvmlReturn_t DECLDIR nvmlDeviceGetAccountingMode(nvmlDevice_t device, nvmlEnableState_t *mode);
+nvmlReturn_t DECLDIR nvmlDeviceGetAccountingStats(nvmlDevice_t device, unsigned int pid, nvmlAccountingStats_t *stats);
+nvmlReturn_t DECLDIR nvmlDeviceGetAccountingPids(nvmlDevice_t device, unsigned int *count, unsigned int *pids);
+nvmlReturn_t DECLDIR nvmlDeviceGetAccountingBufferSize(nvmlDevice_t device, unsigned int *bufferSize);
+nvmlReturn_t DECLDIR nvmlDeviceGetRetiredPages(nvmlDevice_t device, nvmlPageRetirementCause_t cause,
+    unsigned int *pageCount, unsigned long long *addresses);
+nvmlReturn_t DECLDIR nvmlDeviceGetRetiredPages_v2(nvmlDevice_t device, nvmlPageRetirementCause_t cause,
+    unsigned int *pageCount, unsigned long long *addresses, unsigned long long *timestamps);
+nvmlReturn_t DECLDIR nvmlDeviceGetRetiredPagesPendingStatus(nvmlDevice_t device, nvmlEnableState_t *isPending);
+nvmlReturn_t DECLDIR nvmlUnitSetLedState(nvmlUnit_t unit, nvmlLedColor_t color);
+nvmlReturn_t DECLDIR nvmlDeviceSetPersistenceMode(nvmlDevice_t device, nvmlEnableState_t mode);
+nvmlReturn_t DECLDIR nvmlDeviceSetComputeMode(nvmlDevice_t device, nvmlComputeMode_t mode);
+nvmlReturn_t DECLDIR nvmlDeviceSetEccMode(nvmlDevice_t device, nvmlEnableState_t ecc);
+nvmlReturn_t DECLDIR nvmlDeviceClearEccErrorCounts(nvmlDevice_t device, nvmlEccCounterType_t counterType);
+nvmlReturn_t DECLDIR nvmlDeviceSetDriverModel(nvmlDevice_t device, nvmlDriverModel_t driverModel, unsigned int flags);
+nvmlReturn_t DECLDIR nvmlDeviceSetGpuLockedClocks(nvmlDevice_t device, unsigned int minGpuClockMHz, unsigned int maxGpuClockMHz);
+nvmlReturn_t DECLDIR nvmlDeviceResetGpuLockedClocks(nvmlDevice_t device);
+nvmlReturn_t DECLDIR nvmlDeviceSetApplicationsClocks(nvmlDevice_t device, unsigned int memClockMHz, unsigned int graphicsClockMHz);
+nvmlReturn_t DECLDIR nvmlDeviceSetPowerManagementLimit(nvmlDevice_t device, unsigned int limit);
+nvmlReturn_t DECLDIR nvmlDeviceSetGpuOperationMode(nvmlDevice_t device, nvmlGpuOperationMode_t mode);
+nvmlReturn_t DECLDIR nvmlDeviceSetAPIRestriction(nvmlDevice_t device, nvmlRestrictedAPI_t apiType, nvmlEnableState_t isRestricted);
+nvmlReturn_t DECLDIR nvmlDeviceSetAccountingMode(nvmlDevice_t device, nvmlEnableState_t mode);
+nvmlReturn_t DECLDIR nvmlDeviceClearAccountingPids(nvmlDevice_t device);
+nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkState(nvmlDevice_t device, unsigned int link, nvmlEnableState_t *isActive);
+nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkVersion(nvmlDevice_t device, unsigned int link, unsigned int *version);
+nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkCapability(nvmlDevice_t device, unsigned int link,
+                                                   nvmlNvLinkCapability_t capability, unsigned int *capResult);
+nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkRemotePciInfo(nvmlDevice_t device, unsigned int link, nvmlPciInfo_t *pci);
+nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkErrorCounter(nvmlDevice_t device, unsigned int link,
+                                                     nvmlNvLinkErrorCounter_t counter, unsigned long long *counterValue);
+nvmlReturn_t DECLDIR nvmlDeviceResetNvLinkErrorCounters(nvmlDevice_t device, unsigned int link);
+nvmlReturn_t DECLDIR nvmlDeviceSetNvLinkUtilizationControl(nvmlDevice_t device, unsigned int link, unsigned int counter,
+                                                           nvmlNvLinkUtilizationControl_t *control, unsigned int reset);
+nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkUtilizationControl(nvmlDevice_t device, unsigned int link, unsigned int counter,
+                                                           nvmlNvLinkUtilizationControl_t *control);
+nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkUtilizationCounter(nvmlDevice_t device, unsigned int link, unsigned int counter,
+                                                           unsigned long long *rxcounter, unsigned long long *txcounter);
+nvmlReturn_t DECLDIR nvmlDeviceFreezeNvLinkUtilizationCounter (nvmlDevice_t device, unsigned int link,
+                                            unsigned int counter, nvmlEnableState_t freeze);
+nvmlReturn_t DECLDIR nvmlDeviceResetNvLinkUtilizationCounter (nvmlDevice_t device, unsigned int link, unsigned int counter);
+nvmlReturn_t DECLDIR nvmlEventSetCreate(nvmlEventSet_t *set);
+nvmlReturn_t DECLDIR nvmlDeviceRegisterEvents(nvmlDevice_t device, unsigned long long eventTypes, nvmlEventSet_t set);
+nvmlReturn_t DECLDIR nvmlDeviceGetSupportedEventTypes(nvmlDevice_t device, unsigned long long *eventTypes);
+nvmlReturn_t DECLDIR nvmlEventSetWait(nvmlEventSet_t set, nvmlEventData_t * data, unsigned int timeoutms);
+nvmlReturn_t DECLDIR nvmlEventSetFree(nvmlEventSet_t set);
+nvmlReturn_t DECLDIR nvmlDeviceModifyDrainState (nvmlPciInfo_t *pciInfo, nvmlEnableState_t newState);
+nvmlReturn_t DECLDIR nvmlDeviceQueryDrainState (nvmlPciInfo_t *pciInfo, nvmlEnableState_t *currentState);
+nvmlReturn_t DECLDIR nvmlDeviceRemoveGpu (nvmlPciInfo_t *pciInfo, nvmlDetachGpuState_t gpuState, nvmlPcieLinkState_t linkState);
+nvmlReturn_t DECLDIR nvmlDeviceDiscoverGpus (nvmlPciInfo_t *pciInfo);
+nvmlReturn_t DECLDIR nvmlDeviceGetFieldValues(nvmlDevice_t device, int valuesCount, nvmlFieldValue_t *values);
+nvmlReturn_t DECLDIR nvmlDeviceGetVirtualizationMode(nvmlDevice_t device, nvmlGpuVirtualizationMode_t *pVirtualMode);
+nvmlReturn_t DECLDIR nvmlDeviceGetHostVgpuMode(nvmlDevice_t device, nvmlHostVgpuMode_t *pHostVgpuMode);
+nvmlReturn_t DECLDIR nvmlDeviceSetVirtualizationMode(nvmlDevice_t device, nvmlGpuVirtualizationMode_t virtualMode);
+nvmlReturn_t DECLDIR nvmlDeviceGetGridLicensableFeatures(nvmlDevice_t device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures);
+nvmlReturn_t DECLDIR nvmlDeviceGetProcessUtilization(nvmlDevice_t device, nvmlProcessUtilizationSample_t *utilization,
+                                              unsigned int *processSamplesCount, unsigned long long lastSeenTimeStamp);
+nvmlReturn_t DECLDIR nvmlDeviceGetSupportedVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds);
+nvmlReturn_t DECLDIR nvmlDeviceGetCreatableVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds);
+nvmlReturn_t DECLDIR nvmlVgpuTypeGetClass(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeClass, unsigned int *size);
+nvmlReturn_t DECLDIR nvmlVgpuTypeGetName(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeName, unsigned int *size);
+nvmlReturn_t DECLDIR nvmlVgpuTypeGetDeviceID(nvmlVgpuTypeId_t vgpuTypeId, unsigned long long *deviceID, unsigned long long *subsystemID);
+nvmlReturn_t DECLDIR nvmlVgpuTypeGetFramebufferSize(nvmlVgpuTypeId_t vgpuTypeId, unsigned long long *fbSize);
+nvmlReturn_t DECLDIR nvmlVgpuTypeGetNumDisplayHeads(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *numDisplayHeads);
+nvmlReturn_t DECLDIR nvmlVgpuTypeGetResolution(nvmlVgpuTypeId_t vgpuTypeId, unsigned int displayIndex, unsigned int *xdim, unsigned int *ydim);
+nvmlReturn_t DECLDIR nvmlVgpuTypeGetLicense(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeLicenseString, unsigned int size);
+nvmlReturn_t DECLDIR nvmlVgpuTypeGetFrameRateLimit(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *frameRateLimit);
+nvmlReturn_t DECLDIR nvmlVgpuTypeGetMaxInstances(nvmlDevice_t device, nvmlVgpuTypeId_t vgpuTypeId, unsigned int *vgpuInstanceCount);
+nvmlReturn_t DECLDIR nvmlVgpuTypeGetMaxInstancesPerVm(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *vgpuInstanceCountPerVm);
+nvmlReturn_t DECLDIR nvmlDeviceGetActiveVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuInstance_t *vgpuInstances);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetVmID(nvmlVgpuInstance_t vgpuInstance, char *vmId, unsigned int size, nvmlVgpuVmIdType_t *vmIdType);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetUUID(nvmlVgpuInstance_t vgpuInstance, char *uuid, unsigned int size);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetVmDriverVersion(nvmlVgpuInstance_t vgpuInstance, char* version, unsigned int length);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFbUsage(nvmlVgpuInstance_t vgpuInstance, unsigned long long *fbUsage);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetLicenseStatus(nvmlVgpuInstance_t vgpuInstance, unsigned int *licensed);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetType(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuTypeId_t *vgpuTypeId);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFrameRateLimit(nvmlVgpuInstance_t vgpuInstance, unsigned int *frameRateLimit);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEccMode(nvmlVgpuInstance_t vgpuInstance, nvmlEnableState_t *eccMode);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int *encoderCapacity);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceSetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int encoderCapacity);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderStats(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount,
+                                                     unsigned int *averageFps, unsigned int *averageLatency);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderSessions(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount, nvmlEncoderSessionInfo_t *sessionInfo);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFBCStats(nvmlVgpuInstance_t vgpuInstance, nvmlFBCStats_t *fbcStats);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFBCSessions(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount, nvmlFBCSessionInfo_t *sessionInfo);
+typedef struct nvmlVgpuVersion_st
+{
+    unsigned int minVersion;
+    unsigned int maxVersion;
+} nvmlVgpuVersion_t;
+typedef struct nvmlVgpuMetadata_st
+{
+    unsigned int version;
+    unsigned int revision;
+    nvmlVgpuGuestInfoState_t guestInfoState;
+    char guestDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE];
+    char hostDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE];
+    unsigned int reserved[6];
+    unsigned int vgpuVirtualizationCaps;
+    unsigned int guestVgpuVersion;
+    unsigned int opaqueDataSize;
+    char opaqueData[4];
+} nvmlVgpuMetadata_t;
+typedef struct nvmlVgpuPgpuMetadata_st
+{
+    unsigned int version;
+    unsigned int revision;
+    char hostDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE];
+    unsigned int pgpuVirtualizationCaps;
+    unsigned int reserved[5];
+    nvmlVgpuVersion_t hostSupportedVgpuRange;
+    unsigned int opaqueDataSize;
+    char opaqueData[4];
+} nvmlVgpuPgpuMetadata_t;
+typedef enum nvmlVgpuVmCompatibility_enum
+{
+    NVML_VGPU_VM_COMPATIBILITY_NONE = 0x0,
+    NVML_VGPU_VM_COMPATIBILITY_COLD = 0x1,
+    NVML_VGPU_VM_COMPATIBILITY_HIBERNATE = 0x2,
+    NVML_VGPU_VM_COMPATIBILITY_SLEEP = 0x4,
+    NVML_VGPU_VM_COMPATIBILITY_LIVE = 0x8,
+} nvmlVgpuVmCompatibility_t;
+typedef enum nvmlVgpuPgpuCompatibilityLimitCode_enum
+{
+    NVML_VGPU_COMPATIBILITY_LIMIT_NONE = 0x0,
+    NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER = 0x1,
+    NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER = 0x2,
+    NVML_VGPU_COMPATIBILITY_LIMIT_GPU = 0x4,
+    NVML_VGPU_COMPATIBILITY_LIMIT_OTHER = 0x80000000,
+} nvmlVgpuPgpuCompatibilityLimitCode_t;
+typedef struct nvmlVgpuPgpuCompatibility_st
+{
+    nvmlVgpuVmCompatibility_t vgpuVmCompatibility;
+    nvmlVgpuPgpuCompatibilityLimitCode_t compatibilityLimitCode;
+} nvmlVgpuPgpuCompatibility_t;
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetMetadata(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuMetadata_t *vgpuMetadata, unsigned int *bufferSize);
+nvmlReturn_t DECLDIR nvmlDeviceGetVgpuMetadata(nvmlDevice_t device, nvmlVgpuPgpuMetadata_t *pgpuMetadata, unsigned int *bufferSize);
+nvmlReturn_t DECLDIR nvmlGetVgpuCompatibility(nvmlVgpuMetadata_t *vgpuMetadata, nvmlVgpuPgpuMetadata_t *pgpuMetadata, nvmlVgpuPgpuCompatibility_t *compatibilityInfo);
+nvmlReturn_t DECLDIR nvmlDeviceGetPgpuMetadataString(nvmlDevice_t device, char *pgpuMetadata, unsigned int *bufferSize);
+nvmlReturn_t DECLDIR nvmlGetVgpuVersion(nvmlVgpuVersion_t *supported, nvmlVgpuVersion_t *current);
+nvmlReturn_t DECLDIR nvmlSetVgpuVersion(nvmlVgpuVersion_t *vgpuVersion);
+nvmlReturn_t DECLDIR nvmlDeviceGetVgpuUtilization(nvmlDevice_t device, unsigned long long lastSeenTimeStamp,
+                                                  nvmlValueType_t *sampleValType, unsigned int *vgpuInstanceSamplesCount,
+                                                  nvmlVgpuInstanceUtilizationSample_t *utilizationSamples);
+nvmlReturn_t DECLDIR nvmlDeviceGetVgpuProcessUtilization(nvmlDevice_t device, unsigned long long lastSeenTimeStamp,
+                                                         unsigned int *vgpuProcessSamplesCount,
+                                                         nvmlVgpuProcessUtilizationSample_t *utilizationSamples);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingMode(nvmlVgpuInstance_t vgpuInstance, nvmlEnableState_t *mode);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingPids(nvmlVgpuInstance_t vgpuInstance, unsigned int *count, unsigned int *pids);
+nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingStats(nvmlVgpuInstance_t vgpuInstance, unsigned int pid, nvmlAccountingStats_t *stats);
+typedef struct nvmlBlacklistDeviceInfo_st
+{
+    nvmlPciInfo_t pciInfo;
+    char uuid[NVML_DEVICE_UUID_BUFFER_SIZE];
+} nvmlBlacklistDeviceInfo_t;
+nvmlReturn_t DECLDIR nvmlGetBlacklistDeviceCount(unsigned int *deviceCount);
+nvmlReturn_t DECLDIR nvmlGetBlacklistDeviceInfoByIndex(unsigned int index, nvmlBlacklistDeviceInfo_t *info);
+#if defined(__NVML_API_VERSION_INTERNAL)
+#undef nvmlDeviceGetGridLicensableFeatures
+#undef nvmlDeviceRemoveGpu
+#undef nvmlDeviceGetNvLinkRemotePciInfo
+#undef nvmlDeviceGetPciInfo
+#undef nvmlDeviceGetCount
+#undef nvmlDeviceGetHandleByIndex
+#undef nvmlDeviceGetHandleByPciBusId
+#undef nvmlInit
+#endif
+#ifdef __cplusplus
+}
+#endif
+#endif
