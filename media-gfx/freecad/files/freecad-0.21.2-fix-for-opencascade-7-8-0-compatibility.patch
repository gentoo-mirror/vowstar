From 4e83b5a0ec0d311bbebbd58f948fc6e10edbb1d7 Mon Sep 17 00:00:00 2001
From: bgbsww <120601209+bgbsww@users.noreply.github.com>
Date: Tue, 9 Jan 2024 20:47:25 -0500
Subject: [PATCH] Add support for OCCT 7.8.0 (#11909)

Signed-off-by: Huang Rui <vowstar@gmail.com>
---
 cMake/FindOCC.cmake                           |  21 +-
 .../inc/SMESHDS_DataMapOfShape.hxx            |  17 +-
 .../salomesmesh/inc/SMESH_MeshVSLink.hxx      |   3 -
 src/3rdParty/salomesmesh/inc/SMESH_SMESH.hxx  |   1 +
 .../salomesmesh/inc/SMESH_SequenceOfNode.hxx  |   3 +-
 .../salomesmesh/inc/SMESH_TypeDefs.hxx        |   7 +
 .../src/DriverSTL/DriverSTL_R_SMDS_Mesh.cpp   |  29 +-
 .../StdMeshers/StdMeshers_Quadrangle_2D.cpp   |   1 -
 src/Mod/Fem/Gui/TaskCreateNodeSet.cpp         |  49 ++-
 src/Mod/Import/App/ImportOCAF.cpp             | 414 +++++++++++-------
 src/Mod/Import/App/ImportOCAF2.h              |  25 +-
 src/Mod/Import/App/Tools.h                    |  79 ++++
 src/Mod/MeshPart/App/CurveProjector.h         | 181 ++++----
 src/Mod/Part/App/ImportStep.cpp               |   5 +
 src/Mod/Part/App/TopoShapePyImp.cpp           |   8 +
 src/Mod/Part/Gui/AppPartGui.cpp               |   1 -
 src/Mod/Part/Gui/Command.cpp                  |   1 -
 src/Mod/Part/Gui/CommandSimple.cpp            |   1 -
 src/Mod/Part/Gui/CrossSections.cpp            |   1 -
 src/Mod/Part/Gui/ViewProvider2DObject.cpp     |   1 -
 src/Mod/Part/Gui/ViewProviderExt.cpp          |  12 +
 src/Mod/Part/Gui/ViewProviderExt.h            |   1 -
 src/Mod/Part/Gui/ViewProviderMirror.cpp       |   1 -
 src/Mod/Part/Gui/ViewProviderPython.cpp       |   1 -
 src/Mod/Part/Gui/ViewProviderReference.h      |   1 -
 src/Mod/Path/App/Voronoi.cpp                  |   3 +-
 src/Mod/Path/Gui/PreCompiled.h                |   2 -
 src/Mod/Robot/Gui/PreCompiled.h               |   2 -
 src/Mod/Sketcher/Gui/EditDatumDialog.cpp      |   1 -
 29 files changed, 568 insertions(+), 304 deletions(-)
 create mode 100644 src/Mod/Import/App/Tools.h

diff --git a/cMake/FindOCC.cmake b/cMake/FindOCC.cmake
index 48e5c98750d4..c72066f43e2f 100644
--- a/cMake/FindOCC.cmake
+++ b/cMake/FindOCC.cmake
@@ -127,8 +127,6 @@ if(OCC_FOUND)
     TKG2d
     TKG3d
     TKMath
-    TKIGES
-    TKSTL
     TKShHealing
     TKXSBase
     TKBool
@@ -139,10 +137,6 @@ if(OCC_FOUND)
     TKGeomBase
     TKOffset
     TKPrim
-    TKSTEPBase
-    TKSTEPAttr
-    TKSTEP209
-    TKSTEP
     TKHLR
     TKFeat
   )
@@ -154,17 +148,20 @@ if(OCC_FOUND)
     TKLCAF
     TKVCAF
     TKCDF
-    TKXDESTEP
-    TKXDEIGES
     TKMeshVS
     TKService
     TKV3d
   )
-  if(OCC_VERSION_STRING VERSION_LESS 6.7.3)
-    list(APPEND OCC_OCAF_LIBRARIES TKAdvTools)
-  elseif(NOT OCC_VERSION_STRING VERSION_LESS 7.5.0)
+
+  if(NOT OCC_VERSION_STRING VERSION_LESS 7.5.0)
     list(APPEND OCC_OCAF_LIBRARIES TKRWMesh)
-  endif(OCC_VERSION_STRING VERSION_LESS 6.7.3)
+  endif(NOT OCC_VERSION_STRING VERSION_LESS 7.5.0)
+  if(OCC_VERSION_STRING VERSION_LESS 7.8.0)
+    list(APPEND OCC_LIBRARIES TKIGES TKSTL TKSTEPBase TKSTEPAttr TKSTEP209 TKSTEP)
+    list(APPEND OCC_OCAF_LIBRARIES TKXDESTEP TKXDEIGES)
+  else(OCC_VERSION_STRING VERSION_LESS 7.8.0)
+    list(APPEND OCC_LIBRARIES TKDESTEP TKDEIGES TKDEGLTF TKDESTL)
+  endif(OCC_VERSION_STRING VERSION_LESS 7.8.0)
   message(STATUS "-- Found OCE/OpenCASCADE version: ${OCC_VERSION_STRING}")
   message(STATUS "-- OCE/OpenCASCADE include directory: ${OCC_INCLUDE_DIR}")
   message(STATUS "-- OCE/OpenCASCADE shared libraries directory: ${OCC_LIBRARY_DIR}")
diff --git a/src/3rdParty/salomesmesh/inc/SMESHDS_DataMapOfShape.hxx b/src/3rdParty/salomesmesh/inc/SMESHDS_DataMapOfShape.hxx
index 3e083cd84d78..67e9f91cde88 100644
--- a/src/3rdParty/salomesmesh/inc/SMESHDS_DataMapOfShape.hxx
+++ b/src/3rdParty/salomesmesh/inc/SMESHDS_DataMapOfShape.hxx
@@ -29,13 +29,26 @@
 
 #include <TopoDS_Shape.hxx>
 
+#include <Standard_Version.hxx>
+
 /*
  * This method needed for instance NCollection_DataMap with TopoDS_Shape as key
  */
+#if OCC_VERSION_HEX >= 0x070800
+struct SMESHDS_Hasher
+{
+  size_t operator()(const TopoDS_Shape& S) const noexcept {
+    return std::hash<TopoDS_Shape>{}(S);
+  }
+  size_t operator()(const TopoDS_Shape& S1, const TopoDS_Shape& S2) const noexcept {
+    return S1.IsSame(S2);
+  }
+};
+#else
 struct SMESHDS_Hasher
 {
   static inline Standard_Boolean IsEqual(const TopoDS_Shape& S1,
-                                         const TopoDS_Shape& S2)
+                                        const TopoDS_Shape& S2)
   {
     return S1.IsSame(S2);
   }
@@ -45,6 +58,6 @@ struct SMESHDS_Hasher
     return ::HashCode( S, Upper);
   }
 };
-
+#endif
 
 #endif
diff --git a/src/3rdParty/salomesmesh/inc/SMESH_MeshVSLink.hxx b/src/3rdParty/salomesmesh/inc/SMESH_MeshVSLink.hxx
index 3bc552eb23d3..6155e2053999 100644
--- a/src/3rdParty/salomesmesh/inc/SMESH_MeshVSLink.hxx
+++ b/src/3rdParty/salomesmesh/inc/SMESH_MeshVSLink.hxx
@@ -57,9 +57,6 @@
 #ifndef _MeshVS_EntityType_HeaderFile
 #include <MeshVS_EntityType.hxx>
 #endif
-#ifndef _Standard_Address_HeaderFile
-#include <Standard_Address.hxx>
-#endif
 #ifndef _TColStd_HArray1OfInteger_HeaderFile
 #include <TColStd_HArray1OfInteger.hxx>
 #endif
diff --git a/src/3rdParty/salomesmesh/inc/SMESH_SMESH.hxx b/src/3rdParty/salomesmesh/inc/SMESH_SMESH.hxx
index 1094aed0dfdd..a8fe257ea70f 100644
--- a/src/3rdParty/salomesmesh/inc/SMESH_SMESH.hxx
+++ b/src/3rdParty/salomesmesh/inc/SMESH_SMESH.hxx
@@ -37,4 +37,5 @@
  #define SMESH_EXPORT
 #endif
 
+#include <Standard_Version.hxx>
 #endif
diff --git a/src/3rdParty/salomesmesh/inc/SMESH_SequenceOfNode.hxx b/src/3rdParty/salomesmesh/inc/SMESH_SequenceOfNode.hxx
index ada6c8b98bf3..33c7203cc8d6 100644
--- a/src/3rdParty/salomesmesh/inc/SMESH_SequenceOfNode.hxx
+++ b/src/3rdParty/salomesmesh/inc/SMESH_SequenceOfNode.hxx
@@ -28,10 +28,11 @@
 
 #include "SMESH_SMESH.hxx"
 
-#include <NCollection_DefineSequence.hxx>
 #if OCC_VERSION_HEX >= 0x060703
 #include <NCollection_IncAllocator.hxx>
 #include <NCollection_Sequence.hxx>
+#else
+#include <NCollection_DefineSequence.hxx>
 #endif
 
 typedef const SMDS_MeshNode* SMDS_MeshNodePtr;
diff --git a/src/3rdParty/salomesmesh/inc/SMESH_TypeDefs.hxx b/src/3rdParty/salomesmesh/inc/SMESH_TypeDefs.hxx
index ac7aa480d80b..7090537c466c 100644
--- a/src/3rdParty/salomesmesh/inc/SMESH_TypeDefs.hxx
+++ b/src/3rdParty/salomesmesh/inc/SMESH_TypeDefs.hxx
@@ -185,11 +185,18 @@ typedef std::vector< UVPtStruct > UVPtStructVec;
 
 // --------------------------------------------------------------------------------
 // class SMESH_SequenceOfElemPtr
+#include <Standard_Version.hxx>
+#if OCC_VERSION_HEX >= 0x060703
+#include <NCollection_Sequence.hxx>
+#else
 #include <NCollection_DefineSequence.hxx>
+#endif
 
 class SMDS_MeshElement;
 
 typedef const SMDS_MeshElement* SMDS_MeshElementPtr;
+#define DEFINE_SEQUENCE(_ClassName_, _BaseCollection_, TheItemType)            \
+typedef NCollection_Sequence<TheItemType > _ClassName_;
 
 DEFINE_SEQUENCE (SMESH_SequenceOfElemPtr, SMESH_BaseCollectionElemPtr, SMDS_MeshElementPtr)
 
diff --git a/src/3rdParty/salomesmesh/src/DriverSTL/DriverSTL_R_SMDS_Mesh.cpp b/src/3rdParty/salomesmesh/src/DriverSTL/DriverSTL_R_SMDS_Mesh.cpp
index ec3ea2e8e394..4b3791292a74 100644
--- a/src/3rdParty/salomesmesh/src/DriverSTL/DriverSTL_R_SMDS_Mesh.cpp
+++ b/src/3rdParty/salomesmesh/src/DriverSTL/DriverSTL_R_SMDS_Mesh.cpp
@@ -33,10 +33,33 @@
 #include "SMDS_MeshNode.hxx"
 #include "SMESH_File.hxx"
 
+#include <Standard_Version.hxx>
+
 namespace
 {
   struct Hasher
   {
+#if OCC_VERSION_HEX >= 0x070800
+    size_t operator()(const gp_Pnt& point) const noexcept
+    {
+      union
+      {
+        Standard_Real    R[3];
+        Standard_Integer I[6];
+      } U;
+
+      point.Coord( U.R[0], U.R[1], U.R[2] );
+      return std::hash<Standard_Integer>{}(U.I[0]/23+U.I[1]/19+U.I[2]/17+U.I[3]/13+U.I[4]/11+U.I[5]/7);
+    }
+
+    size_t operator()(const gp_Pnt& point1, const gp_Pnt& point2) const noexcept
+    {
+      static Standard_Real tab1[3], tab2[3];
+      point1.Coord(tab1[0],tab1[1],tab1[2]);
+      point2.Coord(tab2[0],tab2[1],tab2[2]);
+      return (memcmp(tab1,tab2,sizeof(tab1)) == 0);
+    }
+#else
     //=======================================================================
     //function : HashCode
     //purpose  :
@@ -51,9 +74,9 @@ namespace
       } U;
 
       point.Coord( U.R[0], U.R[1], U.R[2] );
-
-      return ::HashCode(U.I[0]/23+U.I[1]/19+U.I[2]/17+U.I[3]/13+U.I[4]/11+U.I[5]/7,Upper);
+      return std::hash<Standard_Integer>{}(U.I[0]/23+U.I[1]/19+U.I[2]/17+U.I[3]/13+U.I[4]/11+U.I[5]/7);
     }
+ 
     //=======================================================================
     //function : IsEqual
     //purpose  :
@@ -66,7 +89,9 @@ namespace
       point2.Coord(tab2[0],tab2[1],tab2[2]);
       return (memcmp(tab1,tab2,sizeof(tab1)) == 0);
     }
+#endif
   };
+
   typedef NCollection_DataMap<gp_Pnt,SMDS_MeshNode*,Hasher> TDataMapOfPntNodePtr;
 
   const int HEADER_SIZE           = 84;
diff --git a/src/3rdParty/salomesmesh/src/StdMeshers/StdMeshers_Quadrangle_2D.cpp b/src/3rdParty/salomesmesh/src/StdMeshers/StdMeshers_Quadrangle_2D.cpp
index 5d5c15c36612..5ebf9dbfb43c 100644
--- a/src/3rdParty/salomesmesh/src/StdMeshers/StdMeshers_Quadrangle_2D.cpp
+++ b/src/3rdParty/salomesmesh/src/StdMeshers/StdMeshers_Quadrangle_2D.cpp
@@ -48,7 +48,6 @@
 #include <Bnd_Box.hxx>
 #include <GeomAPI_ProjectPointOnSurf.hxx>
 #include <Geom_Surface.hxx>
-#include <NCollection_DefineArray2.hxx>
 #include <Precision.hxx>
 #include <Standard_Real.hxx>
 #include <TColStd_SequenceOfInteger.hxx>
diff --git a/src/Mod/Fem/Gui/TaskCreateNodeSet.cpp b/src/Mod/Fem/Gui/TaskCreateNodeSet.cpp
index 4e69796b26fe..af4221a39543 100644
--- a/src/Mod/Fem/Gui/TaskCreateNodeSet.cpp
+++ b/src/Mod/Fem/Gui/TaskCreateNodeSet.cpp
@@ -22,13 +22,12 @@
 
 #include "PreCompiled.h"
 #ifndef _PreComp_
-# include <Inventor/events/SoMouseButtonEvent.h>
-# include <Inventor/nodes/SoCamera.h>
-# include <Inventor/nodes/SoEventCallback.h>
+#include <Inventor/events/SoMouseButtonEvent.h>
+#include <Inventor/nodes/SoCamera.h>
+#include <Inventor/nodes/SoEventCallback.h>
 
-# include <SMESH_Mesh.hxx>
-# include <SMESHDS_Mesh.hxx>
-# include <Standard_math.hxx>
+#include <SMESHDS_Mesh.hxx>
+#include <SMESH_Mesh.hxx>
 #endif
 
 #include <Base/Console.h>
@@ -43,10 +42,10 @@
 #include <Mod/Fem/App/FemMeshObject.h>
 #include <Mod/Fem/App/FemSetNodesObject.h>
 
-#include "TaskCreateNodeSet.h"
-#include "ui_TaskCreateNodeSet.h"
 #include "FemSelectionGate.h"
+#include "TaskCreateNodeSet.h"
 #include "ViewProviderFemMesh.h"
+#include "ui_TaskCreateNodeSet.h"
 
 
 using namespace FemGui;
@@ -54,10 +53,10 @@ using namespace Gui;
 
 
 TaskCreateNodeSet::TaskCreateNodeSet(Fem::FemSetNodesObject* pcObject, QWidget* parent)
-    : TaskBox(Gui::BitmapFactory().pixmap("FEM_CreateNodesSet"), tr("Nodes set"), true, parent),
-      pcObject(pcObject),
-      selectionMode(none),
-      ui(new Ui_TaskCreateNodeSet)
+    : TaskBox(Gui::BitmapFactory().pixmap("FEM_CreateNodesSet"), tr("Nodes set"), true, parent)
+    , pcObject(pcObject)
+    , selectionMode(none)
+    , ui(new Ui_TaskCreateNodeSet)
 {
     // we need a separate container widget to add all controls to
     proxy = new QWidget(this);
@@ -85,14 +84,13 @@ TaskCreateNodeSet::TaskCreateNodeSet(Fem::FemSetNodesObject* pcObject, QWidget*
     MeshViewProvider->setHighlightNodes(tempSet);
 
     ui->groupBox_AngleSearch->setEnabled(false);
-
 }
 
 void TaskCreateNodeSet::Poly()
 {
     Gui::Document* doc = Gui::Application::Instance->activeDocument();
     Gui::MDIView* view = doc->getActiveView();
-    if (view->getTypeId().isDerivedFrom(Gui::View3DInventor::getClassTypeId())) {
+    if (view->isDerivedFrom<Gui::View3DInventor>()) {
         Gui::View3DInventorViewer* viewer = ((Gui::View3DInventor*)view)->getViewer();
         viewer->setEditing(true);
         viewer->startSelection(Gui::View3DInventorViewer::Clip);
@@ -139,23 +137,27 @@ void TaskCreateNodeSet::DefineNodesCallback(void* ud, SoEventCallback* n)
 
     Gui::SelectionRole role;
     std::vector<SbVec2f> clPoly = view->getGLPolygon(&role);
-    if (clPoly.size() < 3)
+    if (clPoly.size() < 3) {
         return;
-    if (clPoly.front() != clPoly.back())
+    }
+    if (clPoly.front() != clPoly.back()) {
         clPoly.push_back(clPoly.front());
+    }
 
     SoCamera* cam = view->getSoRenderManager()->getCamera();
     SbViewVolume vv = cam->getViewVolume();
     Gui::ViewVolumeProjection proj(vv);
     Base::Polygon2d polygon;
-    for (std::vector<SbVec2f>::const_iterator it = clPoly.begin(); it != clPoly.end(); ++it)
-        polygon.Add(Base::Vector2d((*it)[0], (*it)[1]));
+    for (auto it : clPoly) {
+        polygon.Add(Base::Vector2d(it[0], it[1]));
+    }
 
     taskBox->DefineNodes(polygon, proj, role == Gui::SelectionRole::Inner ? true : false);
 }
 
 void TaskCreateNodeSet::DefineNodes(const Base::Polygon2d& polygon,
-                                    const Gui::ViewVolumeProjection& proj, bool inner)
+                                    const Gui::ViewVolumeProjection& proj,
+                                    bool inner)
 {
     const SMESHDS_Mesh* data = pcObject->FemMesh.getValue<Fem::FemMeshObject*>()
                                    ->FemMesh.getValue()
@@ -165,15 +167,17 @@ void TaskCreateNodeSet::DefineNodes(const Base::Polygon2d& polygon,
     SMDS_NodeIteratorPtr aNodeIter = data->nodesIterator();
     Base::Vector3f pt2d;
 
-    if (!ui->checkBox_Add->isChecked())
+    if (!ui->checkBox_Add->isChecked()) {
         tempSet.clear();
+    }
 
     while (aNodeIter->more()) {
         const SMDS_MeshNode* aNode = aNodeIter->next();
         Base::Vector3f vec(aNode->X(), aNode->Y(), aNode->Z());
         pt2d = proj(vec);
-        if (polygon.Contains(Base::Vector2d(pt2d.x, pt2d.y)) == inner)
+        if (polygon.Contains(Base::Vector2d(pt2d.x, pt2d.y)) == inner) {
             tempSet.insert(aNode->GetID());
+        }
     }
 
     MeshViewProvider->setHighlightNodes(tempSet);
@@ -181,8 +185,9 @@ void TaskCreateNodeSet::DefineNodes(const Base::Polygon2d& polygon,
 
 void TaskCreateNodeSet::onSelectionChanged(const Gui::SelectionChanges& msg)
 {
-    if (selectionMode == none)
+    if (selectionMode == none) {
         return;
+    }
 
     if (msg.Type == Gui::SelectionChanges::AddSelection) {
         std::string subName(msg.pSubName);
diff --git a/src/Mod/Import/App/ImportOCAF.cpp b/src/Mod/Import/App/ImportOCAF.cpp
index 2397b62c379b..7277d0fb193e 100644
--- a/src/Mod/Import/App/ImportOCAF.cpp
+++ b/src/Mod/Import/App/ImportOCAF.cpp
@@ -22,29 +22,29 @@
 
 #include "PreCompiled.h"
 #if defined(__MINGW32__)
-# define WNT // avoid conflict with GUID
+#define WNT  // avoid conflict with GUID
 #endif
 #ifndef _PreComp_
-# include <climits>
-# include <gp_Pln.hxx> // for Precision::Confusion()
-# include <gp_Trsf.hxx>
-# include <Bnd_Box.hxx>
-# include <BRepBndLib.hxx>
-# include <BRep_Builder.hxx>
-# include <BRepExtrema_DistShapeShape.hxx>
-# include <Quantity_ColorRGBA.hxx>
-# include <Standard_Failure.hxx>
-# include <Standard_Version.hxx>
-# include <TDataStd_Name.hxx>
-# include <TDF_ChildIterator.hxx>
-# include <TDF_Label.hxx>
-# include <TDF_LabelSequence.hxx>
-# include <TDocStd_Document.hxx>
-# include <TopExp_Explorer.hxx>
-# include <TopoDS_Iterator.hxx>
-# include <TopTools_IndexedMapOfShape.hxx>
-# include <XCAFDoc_DocumentTool.hxx>
-# include <XCAFDoc_Location.hxx>
+#include <BRepBndLib.hxx>
+#include <BRepExtrema_DistShapeShape.hxx>
+#include <BRep_Builder.hxx>
+#include <Bnd_Box.hxx>
+#include <Quantity_ColorRGBA.hxx>
+#include <Standard_Failure.hxx>
+#include <Standard_Version.hxx>
+#include <TDF_ChildIterator.hxx>
+#include <TDF_Label.hxx>
+#include <TDF_LabelSequence.hxx>
+#include <TDataStd_Name.hxx>
+#include <TDocStd_Document.hxx>
+#include <TopExp_Explorer.hxx>
+#include <TopTools_IndexedMapOfShape.hxx>
+#include <TopoDS_Iterator.hxx>
+#include <XCAFDoc_DocumentTool.hxx>
+#include <XCAFDoc_Location.hxx>
+#include <climits>
+#include <gp_Pln.hxx>  // for Precision::Confusion()
+#include <gp_Trsf.hxx>
 #endif
 
 #include <App/Application.h>
@@ -57,21 +57,21 @@
 
 
 #ifdef HAVE_TBB
-# include <tbb/blocked_range.h>
-# include <tbb/parallel_for.h>
-# include <tbb/task_group.h>
+#include <tbb/blocked_range.h>
+#include <tbb/parallel_for.h>
+#include <tbb/task_group.h>
 #endif
 
 using namespace Import;
 
 #if OCC_VERSION_HEX >= 0x070500
 // See https://dev.opencascade.org/content/occt-3d-viewer-becomes-srgb-aware
-#   define OCC_COLOR_SPACE Quantity_TOC_sRGB
+#define OCC_COLOR_SPACE Quantity_TOC_sRGB
 #else
-#   define OCC_COLOR_SPACE Quantity_TOC_RGB
+#define OCC_COLOR_SPACE Quantity_TOC_RGB
 #endif
 
-static inline App::Color convertColor(const Quantity_ColorRGBA &c)
+static inline App::Color convertColor(const Quantity_ColorRGBA& c)
 {
     Standard_Real r, g, b;
     c.GetRGB().Values(r, g, b, OCC_COLOR_SPACE);
@@ -84,15 +84,15 @@ static inline App::Color convertColor(const Quantity_ColorRGBA &c)
 #define OCAF_KEEP_PLACEMENT
 
 ImportOCAF::ImportOCAF(Handle(TDocStd_Document) h, App::Document* d, const std::string& name)
-    : pDoc(h), doc(d), merge(true), default_name(name)
+    : pDoc(h)
+    , doc(d)
+    , default_name(name)
 {
-    aShapeTool = XCAFDoc_DocumentTool::ShapeTool (pDoc->Main());
+    aShapeTool = XCAFDoc_DocumentTool::ShapeTool(pDoc->Main());
     aColorTool = XCAFDoc_DocumentTool::ColorTool(pDoc->Main());
 }
 
-ImportOCAF::~ImportOCAF()
-{
-}
+ImportOCAF::~ImportOCAF() = default;
 
 void ImportOCAF::tryPlacementFromLoc(App::GeoFeature* part, const TopLoc_Location& part_loc)
 {
@@ -131,11 +131,14 @@ void ImportOCAF::loadShapes()
 
 void ImportOCAF::setMerge(bool merge)
 {
-    this->merge=merge;
+    this->merge = merge;
 }
 
-void ImportOCAF::loadShapes(const TDF_Label& label, const TopLoc_Location& loc,
-                            const std::string& defaultname, const std::string& assembly, bool isRef,
+void ImportOCAF::loadShapes(const TDF_Label& label,
+                            const TopLoc_Location& loc,
+                            const std::string& defaultname,
+                            const std::string& assembly,
+                            bool isRef,
                             std::vector<App::DocumentObject*>& lValue)
 {
     int hash = 0;
@@ -145,59 +148,65 @@ void ImportOCAF::loadShapes(const TDF_Label& label, const TopLoc_Location& loc,
 #endif
     TopoDS_Shape aShape;
 
-    std::vector<App::DocumentObject *> localValue;
+    std::vector<App::DocumentObject*> localValue;
 
-    if (aShapeTool->GetShape(label,aShape)) {
+    if (aShapeTool->GetShape(label, aShape)) {
+#if OCC_VERSION_HEX >= 0x070800
+        hash = std::hash<TopoDS_Shape> {}(aShape);
+#else
         hash = aShape.HashCode(HashUpper);
+#endif
     }
 
     Handle(TDataStd_Name) name;
     std::string part_name = defaultname;
-    if (label.FindAttribute(TDataStd_Name::GetID(),name)) {
+    if (label.FindAttribute(TDataStd_Name::GetID(), name)) {
         TCollection_ExtendedString extstr = name->Get();
-        char* str = new char[extstr.LengthOfCString()+1];
+        char* str = new char[extstr.LengthOfCString() + 1];
         extstr.ToUTF8CString(str);
         part_name = str;
-        delete [] str;
+        delete[] str;
         if (part_name.empty()) {
             part_name = defaultname;
         }
         else {
-            bool ws=true;
-            for (std::string::iterator it = part_name.begin(); it != part_name.end(); ++it) {
-                if (*it != ' ') {
+            bool ws = true;
+            for (char it : part_name) {
+                if (it != ' ') {
                     ws = false;
                     break;
                 }
             }
-            if (ws)
+            if (ws) {
                 part_name = defaultname;
+            }
         }
     }
 
     TopLoc_Location part_loc = loc;
     Handle(XCAFDoc_Location) hLoc;
     if (label.FindAttribute(XCAFDoc_Location::GetID(), hLoc)) {
-        if (isRef)
+        if (isRef) {
             part_loc = part_loc * hLoc->Get();
-        else
+        }
+        else {
             part_loc = hLoc->Get();
+        }
     }
 
 #ifdef FC_DEBUG
     Base::Console().Log("H:%d, N:%s, T:%d, A:%d, S:%d, C:%d, SS:%d, F:%d, R:%d, C:%d, SS:%d\n",
-        hash,
-        part_name.c_str(),
-        aShapeTool->IsTopLevel(label),
-        aShapeTool->IsAssembly(label),
-        aShapeTool->IsShape(label),
-        aShapeTool->IsCompound(label),
-        aShapeTool->IsSimpleShape(label),
-        aShapeTool->IsFree(label),
-        aShapeTool->IsReference(label),
-        aShapeTool->IsComponent(label),
-        aShapeTool->IsSubShape(label)
-    );
+                        hash,
+                        part_name.c_str(),
+                        aShapeTool->IsTopLevel(label),
+                        aShapeTool->IsAssembly(label),
+                        aShapeTool->IsShape(label),
+                        aShapeTool->IsCompound(label),
+                        aShapeTool->IsSimpleShape(label),
+                        aShapeTool->IsFree(label),
+                        aShapeTool->IsReference(label),
+                        aShapeTool->IsComponent(label),
+                        aShapeTool->IsSubShape(label));
 #endif
 
 #if defined(OCAF_KEEP_PLACEMENT)
@@ -217,44 +226,54 @@ void ImportOCAF::loadShapes(const TDF_Label& label, const TopLoc_Location& loc,
 
     if (isRef || myRefShapes.find(hash) == myRefShapes.end()) {
         TopoDS_Shape aShape;
-        if (isRef && aShapeTool->GetShape(label, aShape))
+        if (isRef && aShapeTool->GetShape(label, aShape)) {
+#if OCC_VERSION_HEX >= 0x070800
+            myRefShapes.insert(std::hash<TopoDS_Shape> {}(aShape));
+#else
             myRefShapes.insert(aShape.HashCode(HashUpper));
+#endif
+        }
 
         if (aShapeTool->IsSimpleShape(label) && (isRef || aShapeTool->IsFree(label))) {
-            if (!asm_name.empty())
+            if (!asm_name.empty()) {
                 part_name = asm_name;
+            }
 
-            // TODO: The merge parameter (last one from createShape) should become an Importer/Exporter
-            // option within the FreeCAD preference menu
-            // Currently it is merging STEP Compound Shape into a single Shape Part::Feature which
-            // is an OpenCascade computed Compound
-            if (isRef)
+            // TODO: The merge parameter (last one from createShape) should become an
+            // Importer/Exporter option within the FreeCAD preference menu Currently it is merging
+            // STEP Compound Shape into a single Shape Part::Feature which is an OpenCascade
+            // computed Compound
+            if (isRef) {
                 createShape(label, loc, part_name, lValue, this->merge);
-            else
+            }
+            else {
                 createShape(label, part_loc, part_name, localValue, this->merge);
+            }
         }
         else {
             if (aShapeTool->IsSimpleShape(label)) {
                 // We are not creating a list of Part::Feature in that case but just
                 // a single Part::Feature which has as a Shape a Compound of the Subshapes contained
                 // within the global shape
-                // This is standard behavior of many STEP reader and avoid to register a crazy amount of
-                // Shape within the Tree as STEP file do mostly contain large assemblies
+                // This is standard behavior of many STEP reader and avoid to register a crazy
+                // amount of Shape within the Tree as STEP file do mostly contain large assemblies
                 return;
             }
 
             // This is probably an Assembly let's try to create a Compound with the name
             for (TDF_ChildIterator it(label); it.More(); it.Next()) {
-                if (isRef)
+                if (isRef) {
                     loadShapes(it.Value(), part_loc, part_name, asm_name, false, localValue);
-                else
+                }
+                else {
                     loadShapes(it.Value(), part_loc, part_name, asm_name, isRef, localValue);
+                }
             }
 
             if (!localValue.empty()) {
                 if (aShapeTool->IsAssembly(label)) {
-                    App::Part *pcPart = nullptr;
-                    pcPart = static_cast<App::Part*>(doc->addObject("App::Part",asm_name.c_str()));
+                    App::Part* pcPart = nullptr;
+                    pcPart = static_cast<App::Part*>(doc->addObject("App::Part", asm_name.c_str()));
                     pcPart->Label.setValue(asm_name);
                     pcPart->addObjects(localValue);
 
@@ -270,8 +289,11 @@ void ImportOCAF::loadShapes(const TDF_Label& label, const TopLoc_Location& loc,
     }
 }
 
-void ImportOCAF::createShape(const TDF_Label& label, const TopLoc_Location& loc, const std::string& name,
-                             std::vector<App::DocumentObject*>& lValue, bool mergeShape)
+void ImportOCAF::createShape(const TDF_Label& label,
+                             const TopLoc_Location& loc,
+                             const std::string& name,
+                             std::vector<App::DocumentObject*>& lValue,
+                             bool mergeShape)
 {
     const TopoDS_Shape& aShape = aShapeTool->GetShape(label);
 #ifdef HAVE_TBB
@@ -282,8 +304,8 @@ void ImportOCAF::createShape(const TDF_Label& label, const TopLoc_Location& loc,
     if (!aShape.IsNull() && aShape.ShapeType() == TopAbs_COMPOUND) {
         TopExp_Explorer xp;
         int ctSolids = 0, ctShells = 0, ctVertices = 0, ctEdges = 0;
-        std::vector<App::DocumentObject *> localValue;
-        App::Part *pcPart = nullptr;
+        std::vector<App::DocumentObject*> localValue;
+        App::Part* pcPart = nullptr;
 
         if (mergeShape) {
 
@@ -296,26 +318,26 @@ void ImportOCAF::createShape(const TDF_Label& label, const TopLoc_Location& loc,
             TopoDS_Compound comp;
             builder.MakeCompound(comp);
 
-/*
-            std::vector<App::Color> colors;
-            for (xp.Init(aShape, TopAbs_SOLID); xp.More(); xp.Next(), ctSolids++) {
-                Quantity_Color aColor;
-                App::Color color(0.8f,0.8f,0.8f);
-                if (aColorTool->GetColor(xp.Current(), XCAFDoc_ColorGen, aColor) ||
-                    aColorTool->GetColor(xp.Current(), XCAFDoc_ColorSurf, aColor) ||
-                    aColorTool->GetColor(xp.Current(), XCAFDoc_ColorCurv, aColor)) {
-                    color.r = (float)aColor.Red();
-                    color.g = (float)aColor.Green();
-                    color.b = (float)aColor.Blue();
-                    colors.push_back(color);
-                }
-            }
-
-            if (colors.size() > 1) {
-                createShape(label, loc, name, lValue, false);
-                return;
-            }
-*/
+            /*
+                        std::vector<App::Color> colors;
+                        for (xp.Init(aShape, TopAbs_SOLID); xp.More(); xp.Next(), ctSolids++) {
+                            Quantity_Color aColor;
+                            App::Color color(0.8f,0.8f,0.8f);
+                            if (aColorTool->GetColor(xp.Current(), XCAFDoc_ColorGen, aColor) ||
+                                aColorTool->GetColor(xp.Current(), XCAFDoc_ColorSurf, aColor) ||
+                                aColorTool->GetColor(xp.Current(), XCAFDoc_ColorCurv, aColor)) {
+                                color.r = (float)aColor.Red();
+                                color.g = (float)aColor.Green();
+                                color.b = (float)aColor.Blue();
+                                colors.push_back(color);
+                            }
+                        }
+
+                        if (colors.size() > 1) {
+                            createShape(label, loc, name, lValue, false);
+                            return;
+                        }
+            */
             for (xp.Init(aShape, TopAbs_SOLID); xp.More(); xp.Next(), ctSolids++) {
                 const TopoDS_Shape& sh = xp.Current();
                 if (!sh.IsNull()) {
@@ -346,7 +368,7 @@ void ImportOCAF::createShape(const TDF_Label& label, const TopLoc_Location& loc,
 
             // Ok we got a Compound which is computed
             // Just need to add it to a Part::Feature and push it to lValue
-            if (!comp.IsNull() && (ctSolids||ctShells||ctEdges||ctVertices)) {
+            if (!comp.IsNull() && (ctSolids || ctShells || ctEdges || ctVertices)) {
                 Part::Feature* part = static_cast<Part::Feature*>(doc->addObject("Part::Feature"));
                 // Let's allocate the relative placement of the Compound from the STEP file
                 tryPlacementFromLoc(part, loc);
@@ -373,7 +395,7 @@ void ImportOCAF::createShape(const TDF_Label& label, const TopLoc_Location& loc,
         }
 
         if (!localValue.empty() && !mergeShape) {
-            pcPart = static_cast<App::Part*>(doc->addObject("App::Part",name.c_str()));
+            pcPart = static_cast<App::Part*>(doc->addObject("App::Part", name.c_str()));
             pcPart->Label.setValue(name);
 
             // localValue contain the objects that  must added to the local Part
@@ -381,39 +403,44 @@ void ImportOCAF::createShape(const TDF_Label& label, const TopLoc_Location& loc,
             pcPart->addObjects(localValue);
 
             // Let's compute relative placement of the Part
-/*
-            gp_Trsf trf;
-            Base::Matrix4D mtrx;
-            if ( loc.IsIdentity() )
-                 trf = loc.Transformation();
-            else
-                 trf = TopLoc_Location(loc.FirstDatum()).Transformation();
-            Part::TopoShape::convertToMatrix(trf, mtrx);
-            Base::Placement pl;
-            pl.fromMatrix(mtrx);
-            pcPart->Placement.setValue(pl);
-*/
+            /*
+                        gp_Trsf trf;
+                        Base::Matrix4D mtrx;
+                        if ( loc.IsIdentity() )
+                             trf = loc.Transformation();
+                        else
+                             trf = TopLoc_Location(loc.FirstDatum()).Transformation();
+                        Part::TopoShape::convertToMatrix(trf, mtrx);
+                        Base::Placement pl;
+                        pl.fromMatrix(mtrx);
+                        pcPart->Placement.setValue(pl);
+            */
             lValue.push_back(pcPart);
         }
 
-        if (ctSolids > 0 || ctShells > 0)
+        if (ctSolids > 0 || ctShells > 0) {
             return;
+        }
     }
     else if (!aShape.IsNull()) {
         createShape(aShape, loc, name, lValue);
     }
 }
 
-void ImportOCAF::createShape(const TopoDS_Shape& aShape, const TopLoc_Location& loc, const std::string& name,
+void ImportOCAF::createShape(const TopoDS_Shape& aShape,
+                             const TopLoc_Location& loc,
+                             const std::string& name,
                              std::vector<App::DocumentObject*>& lvalue)
 {
     Part::Feature* part = static_cast<Part::Feature*>(doc->addObject("Part::Feature"));
 
-    if (!loc.IsIdentity())
+    if (!loc.IsIdentity()) {
         // part->Shape.setValue(aShape.Moved(TopLoc_Location(loc.FirstDatum())));
         part->Shape.setValue(aShape.Moved(loc));
-    else
+    }
+    else {
         part->Shape.setValue(aShape);
+    }
 
     part->Label.setValue(name);
     lvalue.push_back(part);
@@ -424,10 +451,10 @@ void ImportOCAF::createShape(const TopoDS_Shape& aShape, const TopLoc_Location&
 void ImportOCAF::loadColors(Part::Feature* part, const TopoDS_Shape& aShape)
 {
     Quantity_ColorRGBA aColor;
-    App::Color color(0.8f,0.8f,0.8f);
-    if (aColorTool->GetColor(aShape, XCAFDoc_ColorGen, aColor) ||
-        aColorTool->GetColor(aShape, XCAFDoc_ColorSurf, aColor) ||
-        aColorTool->GetColor(aShape, XCAFDoc_ColorCurv, aColor)) {
+    App::Color color(0.8f, 0.8f, 0.8f);
+    if (aColorTool->GetColor(aShape, XCAFDoc_ColorGen, aColor)
+        || aColorTool->GetColor(aShape, XCAFDoc_ColorSurf, aColor)
+        || aColorTool->GetColor(aShape, XCAFDoc_ColorCurv, aColor)) {
         color = convertColor(aColor);
         std::vector<App::Color> colors;
         colors.push_back(color);
@@ -435,7 +462,7 @@ void ImportOCAF::loadColors(Part::Feature* part, const TopoDS_Shape& aShape)
     }
 
     TopTools_IndexedMapOfShape faces;
-    TopExp_Explorer xp(aShape,TopAbs_FACE);
+    TopExp_Explorer xp(aShape, TopAbs_FACE);
     while (xp.More()) {
         faces.Add(xp.Current());
         xp.Next();
@@ -444,14 +471,14 @@ void ImportOCAF::loadColors(Part::Feature* part, const TopoDS_Shape& aShape)
     bool found_face_color = false;
     std::vector<App::Color> faceColors;
     faceColors.resize(faces.Extent(), color);
-    xp.Init(aShape,TopAbs_FACE);
+    xp.Init(aShape, TopAbs_FACE);
     while (xp.More()) {
-        if (aColorTool->GetColor(xp.Current(), XCAFDoc_ColorGen, aColor) ||
-            aColorTool->GetColor(xp.Current(), XCAFDoc_ColorSurf, aColor) ||
-            aColorTool->GetColor(xp.Current(), XCAFDoc_ColorCurv, aColor)) {
+        if (aColorTool->GetColor(xp.Current(), XCAFDoc_ColorGen, aColor)
+            || aColorTool->GetColor(xp.Current(), XCAFDoc_ColorSurf, aColor)
+            || aColorTool->GetColor(xp.Current(), XCAFDoc_ColorCurv, aColor)) {
             int index = faces.FindIndex(xp.Current());
             color = convertColor(aColor);
-            faceColors[index-1] = color;
+            faceColors[index - 1] = color;
             found_face_color = true;
         }
         xp.Next();
@@ -466,8 +493,7 @@ void ImportOCAF::loadColors(Part::Feature* part, const TopoDS_Shape& aShape)
 
 ImportOCAFCmd::ImportOCAFCmd(Handle(TDocStd_Document) h, App::Document* d, const std::string& name)
     : ImportOCAF(h, d, name)
-{
-}
+{}
 
 void ImportOCAFCmd::applyColors(Part::Feature* part, const std::vector<App::Color>& colors)
 {
@@ -477,25 +503,25 @@ void ImportOCAFCmd::applyColors(Part::Feature* part, const std::vector<App::Colo
 // ----------------------------------------------------------------------------
 
 ImportXCAF::ImportXCAF(Handle(TDocStd_Document) h, App::Document* d, const std::string& name)
-    : hdoc(h), doc(d), default_name(name)
+    : hdoc(h)
+    , doc(d)
+    , default_name(name)
 {
-    aShapeTool = XCAFDoc_DocumentTool::ShapeTool (hdoc->Main());
+    aShapeTool = XCAFDoc_DocumentTool::ShapeTool(hdoc->Main());
     hColors = XCAFDoc_DocumentTool::ColorTool(hdoc->Main());
 }
 
-ImportXCAF::~ImportXCAF()
-{
-}
+ImportXCAF::~ImportXCAF() = default;
 
 void ImportXCAF::loadShapes()
 {
     // collect sequence of labels to display
     TDF_LabelSequence shapeLabels, colorLabels;
-    aShapeTool->GetFreeShapes (shapeLabels);
+    aShapeTool->GetFreeShapes(shapeLabels);
     hColors->GetColors(colorLabels);
 
     // set presentations and show
-    for (Standard_Integer i=1; i <= shapeLabels.Length(); i++ ) {
+    for (Standard_Integer i = 1; i <= shapeLabels.Length(); i++) {
         // get the shapes and attributes
         const TDF_Label& label = shapeLabels.Value(i);
         loadShapes(label);
@@ -532,10 +558,14 @@ void ImportXCAF::createShape(const TopoDS_Shape& shape, bool perface, bool setna
     part->Label.setValue(default_name);
     part->Shape.setValue(shape);
     std::map<Standard_Integer, Quantity_ColorRGBA>::const_iterator jt;
+#if OCC_VERSION_HEX >= 0x070800
+    jt = myColorMap.find(std::hash<TopoDS_Shape> {}(shape));
+#else
     jt = myColorMap.find(shape.HashCode(INT_MAX));
+#endif
 
-    App::Color partColor(0.8f,0.8f,0.8f);
-#if 0//TODO
+    App::Color partColor(0.8f, 0.8f, 0.8f);
+#if 0  // TODO
     Gui::ViewProvider* vp = Gui::Application::Instance->getViewProvider(part);
     if (vp && vp->isDerivedFrom(PartGui::ViewProviderPart::getClassTypeId())) {
         if (jt != myColorMap.end()) {
@@ -553,7 +583,11 @@ void ImportXCAF::createShape(const TopoDS_Shape& shape, bool perface, bool setna
     // set label name if defined
     if (setname && !myNameMap.empty()) {
         std::map<Standard_Integer, std::string>::const_iterator jt;
+#if OCC_VERSION_HEX >= 0x070800
+        jt = myNameMap.find(std::hash<TopoDS_Shape> {}(shape));
+#else
         jt = myNameMap.find(shape.HashCode(INT_MAX));
+#endif
         if (jt != myNameMap.end()) {
             part->Label.setValue(jt->second);
         }
@@ -562,7 +596,7 @@ void ImportXCAF::createShape(const TopoDS_Shape& shape, bool perface, bool setna
     // check for colors per face
     if (perface && !myColorMap.empty()) {
         TopTools_IndexedMapOfShape faces;
-        TopExp_Explorer xp(shape,TopAbs_FACE);
+        TopExp_Explorer xp(shape, TopAbs_FACE);
         while (xp.More()) {
             faces.Add(xp.Current());
             xp.Next();
@@ -571,19 +605,23 @@ void ImportXCAF::createShape(const TopoDS_Shape& shape, bool perface, bool setna
         bool found_face_color = false;
         std::vector<App::Color> faceColors;
         faceColors.resize(faces.Extent(), partColor);
-        xp.Init(shape,TopAbs_FACE);
+        xp.Init(shape, TopAbs_FACE);
         while (xp.More()) {
+#if OCC_VERSION_HEX >= 0x070800
+            jt = myColorMap.find(std::hash<TopoDS_Shape> {}(xp.Current()));
+#else
             jt = myColorMap.find(xp.Current().HashCode(INT_MAX));
+#endif
             if (jt != myColorMap.end()) {
                 int index = faces.FindIndex(xp.Current());
-                faceColors[index-1] = convertColor(jt->second);
+                faceColors[index - 1] = convertColor(jt->second);
                 found_face_color = true;
             }
             xp.Next();
         }
 
         if (found_face_color) {
-#if 0//TODO
+#if 0  // TODO
             Gui::ViewProvider* vp = Gui::Application::Instance->getViewProvider(part);
             if (vp && vp->isDerivedFrom(PartGui::ViewProviderPartExt::getClassTypeId())) {
                 static_cast<PartGui::ViewProviderPartExt*>(vp)->DiffuseColor.setValues(faceColors);
@@ -596,69 +634,117 @@ void ImportXCAF::createShape(const TopoDS_Shape& shape, bool perface, bool setna
 void ImportXCAF::loadShapes(const TDF_Label& label)
 {
     TopoDS_Shape aShape;
-    if (aShapeTool->GetShape(label,aShape)) {
-        //if (aShapeTool->IsReference(label)) {
-        //    TDF_Label reflabel;
-        //    if (aShapeTool->GetReferredShape(label, reflabel)) {
-        //        loadShapes(reflabel);
-        //    }
-        //}
+    if (aShapeTool->GetShape(label, aShape)) {
+        // if (aShapeTool->IsReference(label)) {
+        //     TDF_Label reflabel;
+        //     if (aShapeTool->GetReferredShape(label, reflabel)) {
+        //         loadShapes(reflabel);
+        //     }
+        // }
         if (aShapeTool->IsTopLevel(label)) {
             int ctSolids = 0, ctShells = 0, ctComps = 0;
             // add the shapes
             TopExp_Explorer xp;
-            for (xp.Init(aShape, TopAbs_SOLID); xp.More(); xp.Next(), ctSolids++)
+            for (xp.Init(aShape, TopAbs_SOLID); xp.More(); xp.Next(), ctSolids++) {
+#if OCC_VERSION_HEX >= 0x070800
+                this->mySolids[std::hash<TopoDS_Shape> {}(xp.Current())] = (xp.Current());
+#else
                 this->mySolids[xp.Current().HashCode(INT_MAX)] = (xp.Current());
-            for (xp.Init(aShape, TopAbs_SHELL, TopAbs_SOLID); xp.More(); xp.Next(), ctShells++)
+#endif
+            }
+            for (xp.Init(aShape, TopAbs_SHELL, TopAbs_SOLID); xp.More(); xp.Next(), ctShells++) {
+#if OCC_VERSION_HEX >= 0x070800
+                this->myShells[std::hash<TopoDS_Shape> {}(xp.Current())] = (xp.Current());
+#else
                 this->myShells[xp.Current().HashCode(INT_MAX)] = (xp.Current());
+#endif
+            }
             // if no solids and no shells were found then go for compounds
             if (ctSolids == 0 && ctShells == 0) {
-                for (xp.Init(aShape, TopAbs_COMPOUND); xp.More(); xp.Next(), ctComps++)
+                for (xp.Init(aShape, TopAbs_COMPOUND); xp.More(); xp.Next(), ctComps++) {
+#if OCC_VERSION_HEX >= 0x070800
+                    this->myCompds[std::hash<TopoDS_Shape> {}(xp.Current())] = (xp.Current());
+#else
                     this->myCompds[xp.Current().HashCode(INT_MAX)] = (xp.Current());
+#endif
+                }
             }
             if (ctComps == 0) {
-                for (xp.Init(aShape, TopAbs_FACE, TopAbs_SHELL); xp.More(); xp.Next())
+                for (xp.Init(aShape, TopAbs_FACE, TopAbs_SHELL); xp.More(); xp.Next()) {
+#if OCC_VERSION_HEX >= 0x070800
+                    this->myShapes[std::hash<TopoDS_Shape> {}(xp.Current())] = (xp.Current());
+#else
                     this->myShapes[xp.Current().HashCode(INT_MAX)] = (xp.Current());
-                for (xp.Init(aShape, TopAbs_WIRE, TopAbs_FACE); xp.More(); xp.Next())
+#endif
+                }
+                for (xp.Init(aShape, TopAbs_WIRE, TopAbs_FACE); xp.More(); xp.Next()) {
+#if OCC_VERSION_HEX >= 0x070800
+                    this->myShapes[std::hash<TopoDS_Shape> {}(xp.Current())] = (xp.Current());
+#else
                     this->myShapes[xp.Current().HashCode(INT_MAX)] = (xp.Current());
-                for (xp.Init(aShape, TopAbs_EDGE, TopAbs_WIRE); xp.More(); xp.Next())
+#endif
+                }
+                for (xp.Init(aShape, TopAbs_EDGE, TopAbs_WIRE); xp.More(); xp.Next()) {
+#if OCC_VERSION_HEX >= 0x070800
+                    this->myShapes[std::hash<TopoDS_Shape> {}(xp.Current())] = (xp.Current());
+#else
                     this->myShapes[xp.Current().HashCode(INT_MAX)] = (xp.Current());
-                for (xp.Init(aShape, TopAbs_VERTEX, TopAbs_EDGE); xp.More(); xp.Next())
+#endif
+                }
+                for (xp.Init(aShape, TopAbs_VERTEX, TopAbs_EDGE); xp.More(); xp.Next()) {
+#if OCC_VERSION_HEX >= 0x070800
+                    this->myShapes[std::hash<TopoDS_Shape> {}(xp.Current())] = (xp.Current());
+#else
                     this->myShapes[xp.Current().HashCode(INT_MAX)] = (xp.Current());
+#endif
+                }
             }
         }
 
         // getting color
         Quantity_ColorRGBA col;
-        if (hColors->GetColor(label, XCAFDoc_ColorGen, col) ||
-            hColors->GetColor(label, XCAFDoc_ColorSurf, col) ||
-            hColors->GetColor(label, XCAFDoc_ColorCurv, col)) {
+        if (hColors->GetColor(label, XCAFDoc_ColorGen, col)
+            || hColors->GetColor(label, XCAFDoc_ColorSurf, col)
+            || hColors->GetColor(label, XCAFDoc_ColorCurv, col)) {
             // add defined color
+#if OCC_VERSION_HEX >= 0x070800
+            myColorMap[std::hash<TopoDS_Shape> {}(aShape)] = col;
+#else
             myColorMap[aShape.HashCode(INT_MAX)] = col;
+#endif
         }
         else {
             // http://www.opencascade.org/org/forum/thread_17107/
             TopoDS_Iterator it;
-            for (it.Initialize(aShape);it.More(); it.Next()) {
-                if (hColors->GetColor(it.Value(), XCAFDoc_ColorGen, col) ||
-                    hColors->GetColor(it.Value(), XCAFDoc_ColorSurf, col) ||
-                    hColors->GetColor(it.Value(), XCAFDoc_ColorCurv, col)) {
+            for (it.Initialize(aShape); it.More(); it.Next()) {
+                if (hColors->GetColor(it.Value(), XCAFDoc_ColorGen, col)
+                    || hColors->GetColor(it.Value(), XCAFDoc_ColorSurf, col)
+                    || hColors->GetColor(it.Value(), XCAFDoc_ColorCurv, col)) {
                     // add defined color
+#if OCC_VERSION_HEX >= 0x070800
+                    myColorMap[std::hash<TopoDS_Shape> {}(it.Value())] = col;
+#else
                     myColorMap[it.Value().HashCode(INT_MAX)] = col;
+#endif
                 }
             }
         }
 
         // getting names
         Handle(TDataStd_Name) name;
-        if (label.FindAttribute(TDataStd_Name::GetID(),name)) {
+        if (label.FindAttribute(TDataStd_Name::GetID(), name)) {
             TCollection_ExtendedString extstr = name->Get();
-            char* str = new char[extstr.LengthOfCString()+1];
+            char* str = new char[extstr.LengthOfCString() + 1];
             extstr.ToUTF8CString(str);
             std::string labelName(str);
-            if (!labelName.empty())
+            if (!labelName.empty()) {
+#if OCC_VERSION_HEX >= 0x070800
+                myNameMap[std::hash<TopoDS_Shape> {}(aShape)] = labelName;
+#else
                 myNameMap[aShape.HashCode(INT_MAX)] = labelName;
-            delete [] str;
+#endif
+            }
+            delete[] str;
         }
 
 #if 0
diff --git a/src/Mod/Import/App/ImportOCAF2.h b/src/Mod/Import/App/ImportOCAF2.h
index e19b921971e7..30003b613ad4 100644
--- a/src/Mod/Import/App/ImportOCAF2.h
+++ b/src/Mod/Import/App/ImportOCAF2.h
@@ -30,7 +30,6 @@
 #include <unordered_map>
 #include <vector>
 
-#include <TDF_LabelMapHasher.hxx>
 #include <TDocStd_Document.hxx>
 #include <TopoDS_Shape.hxx>
 #include <XCAFDoc_ColorTool.hxx>
@@ -56,15 +55,27 @@ class Feature;
 
 namespace Import {
 
-struct ShapeHasher {
-    std::size_t operator()(const TopoDS_Shape &s) const {
-        return s.HashCode(INT_MAX);
+struct ShapeHasher
+{
+    std::size_t operator()(const TopoDS_Shape& shape) const
+    {
+#if OCC_VERSION_HEX >= 0x070800
+        return std::hash<TopoDS_Shape> {}(shape);
+#else
+        return shape.HashCode(INT_MAX);
+#endif
     }
 };
 
-struct LabelHasher {
-    std::size_t operator()(const TDF_Label &l) const {
-        return TDF_LabelMapHasher::HashCode(l,INT_MAX);
+struct LabelHasher
+{
+    std::size_t operator()(const TDF_Label& label) const
+    {
+#if OCC_VERSION_HEX >= 0x070800
+        return std::hash<TDF_Label> {}(label);
+#else
+        return TDF_LabelMapHasher::HashCode(label, INT_MAX);
+#endif
     }
 };
 
diff --git a/src/Mod/Import/App/Tools.h b/src/Mod/Import/App/Tools.h
new file mode 100644
index 000000000000..aa05e3067e67
--- /dev/null
+++ b/src/Mod/Import/App/Tools.h
@@ -0,0 +1,79 @@
+/****************************************************************************
+ *   Copyright (c) 2018 Zheng, Lei (realthunder) <realthunder.dev@gmail.com>*
+ *                                                                          *
+ *   This file is part of the FreeCAD CAx development system.               *
+ *                                                                          *
+ *   This library is free software; you can redistribute it and/or          *
+ *   modify it under the terms of the GNU Library General Public            *
+ *   License as published by the Free Software Foundation; either           *
+ *   version 2 of the License, or (at your option) any later version.       *
+ *                                                                          *
+ *   This library  is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
+ *   GNU Library General Public License for more details.                   *
+ *                                                                          *
+ *   You should have received a copy of the GNU Library General Public      *
+ *   License along with this library; see the file COPYING.LIB. If not,     *
+ *   write to the Free Software Foundation, Inc., 59 Temple Place,          *
+ *   Suite 330, Boston, MA  02111-1307, USA                                 *
+ *                                                                          *
+ ****************************************************************************/
+
+#ifndef IMPORT_TOOLS_H
+#define IMPORT_TOOLS_H
+
+#include <Quantity_ColorRGBA.hxx>
+#include <TopoDS_Shape.hxx>
+#include <XCAFDoc_ColorTool.hxx>
+#include <XCAFDoc_ShapeTool.hxx>
+#include <App/Color.h>
+
+#include <Standard_Version.hxx>
+
+namespace Import
+{
+
+struct ShapeHasher
+{
+    std::size_t operator()(const TopoDS_Shape& shape) const
+    {
+#if OCC_VERSION_HEX >= 0x070800
+        return std::hash<TopoDS_Shape> {}(shape);
+#else
+        return shape.HashCode(INT_MAX);
+#endif
+    }
+};
+
+struct LabelHasher
+{
+    std::size_t operator()(const TDF_Label& label) const
+    {
+#if OCC_VERSION_HEX >= 0x070800
+        return std::hash<TDF_Label> {}(label);
+#else
+        return TDF_LabelMapHasher::HashCode(label, INT_MAX);
+#endif
+    }
+};
+
+struct Tools
+{
+    static App::Color convertColor(const Quantity_ColorRGBA& rgba);
+    static Quantity_ColorRGBA convertColor(const App::Color& col);
+    static std::string labelName(TDF_Label label);
+    static void printLabel(TDF_Label label,
+                           Handle(XCAFDoc_ShapeTool) aShapeTool,
+                           Handle(XCAFDoc_ColorTool) aColorTool,
+                           const char* msg = nullptr);
+
+    static void dumpLabels(TDF_Label label,
+                           Handle(XCAFDoc_ShapeTool) aShapeTool,
+                           Handle(XCAFDoc_ColorTool) aColorTool,
+                           int depth = 0);
+};
+
+}  // namespace Import
+
+#endif  // IMPORT_IMPORTOCAF2_H
diff --git a/src/Mod/MeshPart/App/CurveProjector.h b/src/Mod/MeshPart/App/CurveProjector.h
index 4fb0d5ff375b..e7d99100ed0a 100644
--- a/src/Mod/MeshPart/App/CurveProjector.h
+++ b/src/Mod/MeshPart/App/CurveProjector.h
@@ -24,7 +24,7 @@
 #define _CurveProjector_h_
 
 #ifdef FC_USE_GTS
-# include <gts.h>
+#include <gts.h>
 #endif
 
 #include <TopoDS_Edge.hxx>
@@ -32,16 +32,17 @@
 #include <Mod/Mesh/App/Mesh.h>
 #include <Mod/MeshPart/MeshPartGlobal.h>
 
+#include <Standard_Version.hxx>
 
 namespace MeshCore
 {
 class MeshKernel;
 class MeshGeomFacet;
 class MeshFacetGrid;
-}
+}  // namespace MeshCore
 
-using MeshCore::MeshKernel;
 using MeshCore::MeshGeomFacet;
+using MeshCore::MeshKernel;
 
 namespace MeshPart
 {
@@ -51,35 +52,44 @@ namespace MeshPart
 class MeshPartExport CurveProjector
 {
 public:
-  CurveProjector(const TopoDS_Shape &aShape, const MeshKernel &pMesh);
-  virtual ~CurveProjector() {}
-
-  struct FaceSplitEdge
-  {
-    MeshCore::FacetIndex ulFaceIndex;
-    Base::Vector3f p1,p2;
-  };
-
-  template<class T>
-    struct TopoDSLess {
-    bool operator()(const T& x, const T& y) const {
-      return x.HashCode(INT_MAX-1) < y.HashCode(INT_MAX-1);
-    }
-  };
+    CurveProjector(const TopoDS_Shape& aShape, const MeshKernel& pMesh);
+    virtual ~CurveProjector() = default;
 
-  using result_type = std::map<TopoDS_Edge, std::vector<FaceSplitEdge>,TopoDSLess<TopoDS_Edge> >;
+    struct FaceSplitEdge
+    {
+        MeshCore::FacetIndex ulFaceIndex;
+        Base::Vector3f p1, p2;
+    };
 
+    template<class T>
+    struct TopoDSLess
+    {
+        bool operator()(const T& x, const T& y) const
+        {
+#if OCC_VERSION_HEX >= 0x070800
+            std::hash<T> hasher;
+            return hasher(x) < hasher(y);
+#else
+            return x.HashCode(INT_MAX - 1) < y.HashCode(INT_MAX - 1);
+#endif
+        }
+    };
 
-  result_type &result() {return  mvEdgeSplitPoints;}
+    using result_type = std::map<TopoDS_Edge, std::vector<FaceSplitEdge>, TopoDSLess<TopoDS_Edge>>;
 
-  void writeIntersectionPointsToFile(const char *name="export_pts.asc");
 
-protected:
-  virtual void Do()=0;
-  const TopoDS_Shape &_Shape;
-  const MeshKernel &_Mesh;
-  result_type mvEdgeSplitPoints;
+    result_type& result()
+    {
+        return mvEdgeSplitPoints;
+    }
+
+    void writeIntersectionPointsToFile(const char* name = "export_pts.asc");
 
+protected:
+    virtual void Do() = 0;
+    const TopoDS_Shape& _Shape;
+    const MeshKernel& _Mesh;
+    result_type mvEdgeSplitPoints;
 };
 
 
@@ -88,44 +98,48 @@ protected:
 class MeshPartExport CurveProjectorShape: public CurveProjector
 {
 public:
-  CurveProjectorShape(const TopoDS_Shape &aShape, const MeshKernel &pMesh);
-  ~CurveProjectorShape() override {}
-
-  void projectCurve(const TopoDS_Edge& aEdge,
-                    std::vector<FaceSplitEdge> &vSplitEdges);
+    CurveProjectorShape(const TopoDS_Shape& aShape, const MeshKernel& pMesh);
+    ~CurveProjectorShape() override = default;
 
-  bool findStartPoint(const MeshKernel &MeshK,const Base::Vector3f &Pnt,Base::Vector3f &Rslt,MeshCore::FacetIndex &FaceIndex);
+    void projectCurve(const TopoDS_Edge& aEdge, std::vector<FaceSplitEdge>& vSplitEdges);
 
+    bool findStartPoint(const MeshKernel& MeshK,
+                        const Base::Vector3f& Pnt,
+                        Base::Vector3f& Rslt,
+                        MeshCore::FacetIndex& FaceIndex);
 
 
 protected:
-  void Do() override;
+    void Do() override;
 };
 
 
-
 /** Project by projecting a sampled curve to the mesh
  */
 class MeshPartExport CurveProjectorSimple: public CurveProjector
 {
 public:
-  CurveProjectorSimple(const TopoDS_Shape &aShape, const MeshKernel &pMesh);
-  ~CurveProjectorSimple() override {}
-
-  /// helper to discredicice a Edge...
-  void GetSampledCurves( const TopoDS_Edge& aEdge, std::vector<Base::Vector3f>& rclPoints, unsigned long ulNbOfPoints = 30);
+    CurveProjectorSimple(const TopoDS_Shape& aShape, const MeshKernel& pMesh);
+    ~CurveProjectorSimple() override = default;
 
+    /// helper to discredicice a Edge...
+    void GetSampledCurves(const TopoDS_Edge& aEdge,
+                          std::vector<Base::Vector3f>& rclPoints,
+                          unsigned long ulNbOfPoints = 30);
 
-  void projectCurve(const TopoDS_Edge& aEdge,
-                    const std::vector<Base::Vector3f> &rclPoints,
-                    std::vector<FaceSplitEdge> &vSplitEdges);
 
-  bool findStartPoint(const MeshKernel &MeshK,const Base::Vector3f &Pnt,Base::Vector3f &Rslt,MeshCore::FacetIndex &FaceIndex);
+    void projectCurve(const TopoDS_Edge& aEdge,
+                      const std::vector<Base::Vector3f>& rclPoints,
+                      std::vector<FaceSplitEdge>& vSplitEdges);
 
+    bool findStartPoint(const MeshKernel& MeshK,
+                        const Base::Vector3f& Pnt,
+                        Base::Vector3f& Rslt,
+                        MeshCore::FacetIndex& FaceIndex);
 
 
 protected:
-  void Do() override;
+    void Do() override;
 };
 
 /** Project by projecting a sampled curve to the mesh
@@ -133,22 +147,25 @@ protected:
 class MeshPartExport CurveProjectorWithToolMesh: public CurveProjector
 {
 public:
-  struct LineSeg {
-    Base::Vector3f p;
-    Base::Vector3f n;
-  };
+    struct LineSeg
+    {
+        Base::Vector3f p;
+        Base::Vector3f n;
+    };
 
-  CurveProjectorWithToolMesh(const TopoDS_Shape &aShape, const MeshKernel &pMesh,MeshKernel &rToolMesh);
-  ~CurveProjectorWithToolMesh() override {}
+    CurveProjectorWithToolMesh(const TopoDS_Shape& aShape,
+                               const MeshKernel& pMesh,
+                               MeshKernel& rToolMesh);
+    ~CurveProjectorWithToolMesh() override = default;
 
 
-  void makeToolMesh(const TopoDS_Edge& aEdge,std::vector<MeshGeomFacet> &cVAry );
+    void makeToolMesh(const TopoDS_Edge& aEdge, std::vector<MeshGeomFacet>& cVAry);
 
 
-  MeshKernel &ToolMesh;
+    MeshKernel& ToolMesh;
 
 protected:
-  void Do() override;
+    void Do() override;
 };
 
 /**
@@ -162,7 +179,7 @@ public:
     struct SplitEdge
     {
         MeshCore::PointIndex uE0, uE1; /**< start and endpoint of an edge */
-        Base::Vector3f cPt; /**< Point on edge (\a uE0, \a uE1) */
+        Base::Vector3f cPt;            /**< Point on edge (\a uE0, \a uE1) */
     };
     struct Edge
     {
@@ -174,10 +191,7 @@ public:
         std::vector<Base::Vector3f> points;
     };
 
-    /// Construction
     explicit MeshProjection(const MeshKernel& rMesh);
-    /// Destruction
-    ~MeshProjection();
 
     /**
      * @brief findSectionParameters
@@ -187,49 +201,66 @@ public:
      * @param dir
      * @param parameters
      */
-    void findSectionParameters(const TopoDS_Edge& edge, const Base::Vector3f& dir, std::set<double>& parameters) const;
-    void discretize(const TopoDS_Edge& aEdge, std::vector<Base::Vector3f>& polyline, std::size_t minPoints=2) const;
+    void findSectionParameters(const TopoDS_Edge& edge,
+                               const Base::Vector3f& dir,
+                               std::set<double>& parameters) const;
+    void discretize(const TopoDS_Edge& aEdge,
+                    std::vector<Base::Vector3f>& polyline,
+                    std::size_t minPoints = 2) const;
     /**
-     * Searches all edges that intersect with the projected curve \a aShape. Therefore \a aShape must
-     * contain shapes of type TopoDS_Edge, other shape types are ignored. A possible solution is
-     * taken if the distance between the curve point and the projected point is <= \a fMaxDist.
+     * Searches all edges that intersect with the projected curve \a aShape. Therefore \a aShape
+     * must contain shapes of type TopoDS_Edge, other shape types are ignored. A possible solution
+     * is taken if the distance between the curve point and the projected point is <= \a fMaxDist.
      */
-    void projectToMesh (const TopoDS_Shape &aShape, float fMaxDist, std::vector<PolyLine>& rPolyLines) const;
+    void projectToMesh(const TopoDS_Shape& aShape,
+                       float fMaxDist,
+                       std::vector<PolyLine>& rPolyLines) const;
     /**
      * @brief projectOnMesh
-     * Projects the given points onto the mesh along a given direction. The points can can be projected
-     * will be saved to \a pointsOut
+     * Projects the given points onto the mesh along a given direction. The points can can be
+     * projected will be saved to \a pointsOut
      * @brief projectOnMesh
      * @param pointsIn
      * @param dir
      * @param tolerance
      * @param pointsOut
      */
-    void projectOnMesh(const std::vector<Base::Vector3f>& pointsIn, const Base::Vector3f& dir,
-                       float tolerance, std::vector<Base::Vector3f>& pointsOut) const;
+    void projectOnMesh(const std::vector<Base::Vector3f>& pointsIn,
+                       const Base::Vector3f& dir,
+                       float tolerance,
+                       std::vector<Base::Vector3f>& pointsOut) const;
     /**
      * Project all edges of the shape onto the mesh using parallel projection.
      */
-    void projectParallelToMesh (const TopoDS_Shape &aShape, const Base::Vector3f& dir, std::vector<PolyLine>& rPolyLines) const;
+    void projectParallelToMesh(const TopoDS_Shape& aShape,
+                               const Base::Vector3f& dir,
+                               std::vector<PolyLine>& rPolyLines) const;
     /**
      * Project all polylines onto the mesh using parallel projection.
      */
-    void projectParallelToMesh (const std::vector<PolyLine>& aEdges, const Base::Vector3f& dir, std::vector<PolyLine>& rPolyLines) const;
+    void projectParallelToMesh(const std::vector<PolyLine>& aEdges,
+                               const Base::Vector3f& dir,
+                               std::vector<PolyLine>& rPolyLines) const;
     /**
-     * Cuts the mesh at the curve defined by \a aShape. This method call @ref projectToMesh() to get the
-     * split the facet at the found points. @see projectToMesh() for more details.
+     * Cuts the mesh at the curve defined by \a aShape. This method call @ref projectToMesh() to get
+     * the split the facet at the found points. @see projectToMesh() for more details.
      */
-    void splitMeshByShape (const TopoDS_Shape &aShape, float fMaxDist) const;
+    void splitMeshByShape(const TopoDS_Shape& aShape, float fMaxDist) const;
 
 protected:
-    void projectEdgeToEdge(const TopoDS_Edge &aCurve, float fMaxDist, const MeshCore::MeshFacetGrid& rGrid,
+    void projectEdgeToEdge(const TopoDS_Edge& aCurve,
+                           float fMaxDist,
+                           const MeshCore::MeshFacetGrid& rGrid,
                            std::vector<SplitEdge>& rSplitEdges) const;
-    bool findIntersection(const Edge&, const Edge&, const Base::Vector3f& dir, Base::Vector3f& res) const;
+    bool findIntersection(const Edge&,
+                          const Edge&,
+                          const Base::Vector3f& dir,
+                          Base::Vector3f& res) const;
 
 private:
     const MeshKernel& _rcMesh;
 };
 
-} // namespace MeshPart
+}  // namespace MeshPart
 
 #endif
diff --git a/src/Mod/Part/App/ImportStep.cpp b/src/Mod/Part/App/ImportStep.cpp
index 6c41ac538062..1d02eb2d6325 100644
--- a/src/Mod/Part/App/ImportStep.cpp
+++ b/src/Mod/Part/App/ImportStep.cpp
@@ -137,7 +137,12 @@ int Part::ImportStepParts(App::Document *pcDoc, const char* Name)
                 // This is a trick to access the GUI via Python and set the color property
                 // of the associated view provider. If no GUI is up an exception is thrown
                 // and cleared immediately
+#if OCC_VERSION_HEX >= 0x070800
+                std::hash<TopoDS_Solid> hasher;
+                std::map<int, Quantity_Color>::iterator it = hash_col.find(hasher(aSolid));
+#else
                 std::map<int, Quantity_Color>::iterator it = hash_col.find(aSolid.HashCode(INT_MAX));
+#endif
                 if (it != hash_col.end()) {
                     try {
                         Py::Object obj(pcFeature->getPyObject(), true);
diff --git a/src/Mod/Part/App/TopoShapePyImp.cpp b/src/Mod/Part/App/TopoShapePyImp.cpp
index c73a70c17750..0bf5f8149448 100644
--- a/src/Mod/Part/App/TopoShapePyImp.cpp
+++ b/src/Mod/Part/App/TopoShapePyImp.cpp
@@ -1304,7 +1304,11 @@ PyObject*  TopoShapePy::ancestorsOfType(PyObject *args)
         TopTools_ListIteratorOfListOfShape it(ancestors);
         for (; it.More(); it.Next()) {
             // make sure to avoid duplicates
+#if OCC_VERSION_HEX >= 0x070800
+            const size_t code = std::hash<TopoDS_Shape>{}(static_cast<TopoDS_Shape>(it.Value()));
+#else
             Standard_Integer code = it.Value().HashCode(INT_MAX);
+#endif
             if (hashes.find(code) == hashes.end()) {
                 list.append(shape2pyshape(it.Value()));
                 hashes.insert(code);
@@ -1919,7 +1923,11 @@ PyObject* TopoShapePy::hashCode(PyObject *args)
     if (!PyArg_ParseTuple(args, "|i",&upper))
         return nullptr;
 
+#if OCC_VERSION_HEX >= 0x070800
+    int hc = std::hash<TopoDS_Shape>{}(getTopoShapePtr()->getShape());
+#else
     int hc = getTopoShapePtr()->getShape().HashCode(upper);
+#endif
     return Py_BuildValue("i", hc);
 }
 
diff --git a/src/Mod/Part/Gui/AppPartGui.cpp b/src/Mod/Part/Gui/AppPartGui.cpp
index 2ca6e878cb3e..54553611430e 100644
--- a/src/Mod/Part/Gui/AppPartGui.cpp
+++ b/src/Mod/Part/Gui/AppPartGui.cpp
@@ -24,7 +24,6 @@
 
 #include "PreCompiled.h"
 #ifndef _PreComp_
-# include <Standard_math.hxx>
 #endif
 
 #include <Base/Console.h>
diff --git a/src/Mod/Part/Gui/Command.cpp b/src/Mod/Part/Gui/Command.cpp
index b057ef4a810e..c8d06c39bf60 100644
--- a/src/Mod/Part/Gui/Command.cpp
+++ b/src/Mod/Part/Gui/Command.cpp
@@ -26,7 +26,6 @@
 # include <QFileInfo>
 # include <QPointer>
 # include <QString>
-# include <Standard_math.hxx>
 # include <Standard_Version.hxx>
 # include <TopExp_Explorer.hxx>
 # include <TopoDS_Shape.hxx>
diff --git a/src/Mod/Part/Gui/CommandSimple.cpp b/src/Mod/Part/Gui/CommandSimple.cpp
index e46d034e1ddf..aaa04fe24932 100644
--- a/src/Mod/Part/Gui/CommandSimple.cpp
+++ b/src/Mod/Part/Gui/CommandSimple.cpp
@@ -23,7 +23,6 @@
 
 #include "PreCompiled.h"
 #ifndef _PreComp_
-# include <Standard_math.hxx>
 # include <QInputDialog>
 #endif
 
diff --git a/src/Mod/Part/Gui/CrossSections.cpp b/src/Mod/Part/Gui/CrossSections.cpp
index 1f42410aaf90..7e35addbc5f8 100644
--- a/src/Mod/Part/Gui/CrossSections.cpp
+++ b/src/Mod/Part/Gui/CrossSections.cpp
@@ -28,7 +28,6 @@
 # include <QKeyEvent>
 
 # include <BRep_Builder.hxx>
-# include <Standard_math.hxx>
 # include <TopoDS.hxx>
 # include <TopoDS_Compound.hxx>
 
diff --git a/src/Mod/Part/Gui/ViewProvider2DObject.cpp b/src/Mod/Part/Gui/ViewProvider2DObject.cpp
index 880586d3373c..61ff90578e20 100644
--- a/src/Mod/Part/Gui/ViewProvider2DObject.cpp
+++ b/src/Mod/Part/Gui/ViewProvider2DObject.cpp
@@ -25,7 +25,6 @@
 #ifndef _PreComp_
 # include <cfloat>
 
-# include <Standard_math.hxx>
 
 # include <Inventor/nodes/SoAnnotation.h>
 # include <Inventor/nodes/SoBaseColor.h>
diff --git a/src/Mod/Part/Gui/ViewProviderExt.cpp b/src/Mod/Part/Gui/ViewProviderExt.cpp
index 554f7a405a67..4ad97b08bd4b 100644
--- a/src/Mod/Part/Gui/ViewProviderExt.cpp
+++ b/src/Mod/Part/Gui/ViewProviderExt.cpp
@@ -987,7 +987,11 @@ void ViewProviderPartExt::updateVisual()
 
             TopExp_Explorer xp;
             for (xp.Init(faceMap(i),TopAbs_EDGE);xp.More();xp.Next())
+#if OCC_VERSION_HEX >= 0x070800
+                faceEdges.insert(std::hash<TopoDS_Shape>{}(xp.Current()));
+#else
                 faceEdges.insert(xp.Current().HashCode(INT_MAX));
+#endif
             numFaces++;
         }
 
@@ -1015,7 +1019,11 @@ void ViewProviderPartExt::updateVisual()
             // So, we have to store the hashes of the edges associated to a face.
             // If the hash of a given edge is not in this list we know it's really
             // a free edge.
+#if OCC_VERSION_HEX >= 0x070800
+            int hash = std::hash<TopoDS_Shape>{}(aEdge);
+#else
             int hash = aEdge.HashCode(INT_MAX);
+#endif
             if (faceEdges.find(hash) == faceEdges.end()) {
                 Handle(Poly_Polygon3D) aPoly = Part::Tools::polygonOfEdge(aEdge, aLoc);
                 if (!aPoly.IsNull()) {
@@ -1214,7 +1222,11 @@ void ViewProviderPartExt::updateVisual()
             TopLoc_Location aLoc;
 
             // handling of the free edge that are not associated to a face
+#if OCC_VERSION_HEX >= 0x070800
+            int hash = std::hash<TopoDS_Shape>{}(aEdge);
+#else
             int hash = aEdge.HashCode(INT_MAX);
+#endif
             if (faceEdges.find(hash) == faceEdges.end()) {
                 Handle(Poly_Polygon3D) aPoly = Part::Tools::polygonOfEdge(aEdge, aLoc);
                 if (!aPoly.IsNull()) {
diff --git a/src/Mod/Part/Gui/ViewProviderExt.h b/src/Mod/Part/Gui/ViewProviderExt.h
index 01b75aaa2a21..94b2866ee670 100644
--- a/src/Mod/Part/Gui/ViewProviderExt.h
+++ b/src/Mod/Part/Gui/ViewProviderExt.h
@@ -24,7 +24,6 @@
 #define PARTGUI_VIEWPROVIDERPARTEXT_H
 
 #include <map>
-#include <Standard_math.hxx>
 
 #include <App/PropertyUnits.h>
 #include <Gui/ViewProviderGeometryObject.h>
diff --git a/src/Mod/Part/Gui/ViewProviderMirror.cpp b/src/Mod/Part/Gui/ViewProviderMirror.cpp
index f9210f90428c..1f9132cc3926 100644
--- a/src/Mod/Part/Gui/ViewProviderMirror.cpp
+++ b/src/Mod/Part/Gui/ViewProviderMirror.cpp
@@ -27,7 +27,6 @@
 # include <QMenu>
 # include <QTimer>
 
-# include <Standard_math.hxx>
 # include <TopExp.hxx>
 # include <TopTools_IndexedMapOfShape.hxx>
 
diff --git a/src/Mod/Part/Gui/ViewProviderPython.cpp b/src/Mod/Part/Gui/ViewProviderPython.cpp
index e7fa75fe1ba3..1b6a1ff8d409 100644
--- a/src/Mod/Part/Gui/ViewProviderPython.cpp
+++ b/src/Mod/Part/Gui/ViewProviderPython.cpp
@@ -22,7 +22,6 @@
 
 #include "PreCompiled.h"
 
-#include <Standard_math.hxx>
 #ifndef _PreComp_
 # include <Inventor/nodes/SoSeparator.h>
 #endif
diff --git a/src/Mod/Part/Gui/ViewProviderReference.h b/src/Mod/Part/Gui/ViewProviderReference.h
index b7a0219b3b23..af40af2fae65 100644
--- a/src/Mod/Part/Gui/ViewProviderReference.h
+++ b/src/Mod/Part/Gui/ViewProviderReference.h
@@ -24,7 +24,6 @@
 #ifndef PARTGUI_ViewProviderPartReference_H
 #define PARTGUI_ViewProviderPartReference_H
 
-#include <Standard_math.hxx>
 #include <Standard_Boolean.hxx>
 #include <TopoDS_Shape.hxx>
 #include <Gui/ViewProviderGeometryObject.h>
diff --git a/src/Mod/Path/App/Voronoi.cpp b/src/Mod/Path/App/Voronoi.cpp
index 27a509c20c07..443b7475075a 100644
--- a/src/Mod/Path/App/Voronoi.cpp
+++ b/src/Mod/Path/App/Voronoi.cpp
@@ -22,7 +22,8 @@
 
 #include "PreCompiled.h"
 #ifndef _PreComp_
-# include <Standard_math.hxx>
+#define _USE_MATH_DEFINES
+# include <math.h>
 #endif
 
 #include <Base/Vector3D.h>
diff --git a/src/Mod/Path/Gui/PreCompiled.h b/src/Mod/Path/Gui/PreCompiled.h
index f12ef8f91985..ed8cef500f31 100644
--- a/src/Mod/Path/Gui/PreCompiled.h
+++ b/src/Mod/Path/Gui/PreCompiled.h
@@ -38,8 +38,6 @@
 # define PathGuiExport
 #endif
 
-#include <Standard_math.hxx>
-
 #ifdef _MSC_VER
 # pragma warning( disable : 4273 )
 #endif
diff --git a/src/Mod/Robot/Gui/PreCompiled.h b/src/Mod/Robot/Gui/PreCompiled.h
index eb2a061446e4..e5496201ecec 100644
--- a/src/Mod/Robot/Gui/PreCompiled.h
+++ b/src/Mod/Robot/Gui/PreCompiled.h
@@ -38,8 +38,6 @@
 # define RobotGuiExport
 #endif
 
-#include <Standard_math.hxx>
-
 #ifdef _MSC_VER
 # pragma warning(disable : 4005)
 # pragma warning(disable : 4273)
diff --git a/src/Mod/Sketcher/Gui/EditDatumDialog.cpp b/src/Mod/Sketcher/Gui/EditDatumDialog.cpp
index dbfd423b999e..ceae48c4ef14 100644
--- a/src/Mod/Sketcher/Gui/EditDatumDialog.cpp
+++ b/src/Mod/Sketcher/Gui/EditDatumDialog.cpp
@@ -23,7 +23,6 @@
 #include "PreCompiled.h"
 
 #ifndef _PreComp_
-#include <Standard_math.hxx>
 /// Qt Include Files
 #include <Inventor/sensors/SoSensor.h>
 #include <QApplication>
-- 
2.44.0

